.so syktsu.tmac
.
.char \[one] \s-2\v'-0.3m'1\v'+0.3m'\s+2
.
.
.TC
.
.
.H1 "Введение"
.PP
Данная работа посвящена задаче распознавания номеров.  Суть этой задачи состоит
в следующем: имеется изображение \*- требуется найти на нем пластину с
автомобильным номером и вывести символы, находящиеся на ней, в виде текста.
.PP
Несмотря на то, что компьютерные программы, решающие данную задачу уже
существуют, некоторые проблемы по-прежнему имеются. Главная из них состоит в
том, что качественных материалов, посвященных решению этой проблемы крайне
мало. В большинстве статей авторы либо используют OpenCV (фреймворк, содержащий
готовые реализации алгоритмов, необходимых для решения), либо утаивают важные
детали реализации, без которых проблему решить невозможно, либо просто
демонстрируют полное непонимание используемых ими методов.
.PP
Первая цель этой работы \*- написать программу, способную распознавать
автомобильные номера, не используя каких-либо сторонних библиотек, кроме
стандартных библиотек языка Си и библиотеки для открытия разных форматов
изображений. Вторая цель \*- это попытаться описать используемые методы
доступным языком, так как, как уже было сказано выше, при их описании часто
упускаются из виду важные детали.
.PP
Задача распознавания автомобильных номеров состоит из нескольких этапов: первый
\*- это нахождение пластины с номером на изображении, второй \*- приведение его
к стандартному виду (исправление перспективных искажений, выравнивание
освещения, и т. д.), а третий \*- распознавание символов, находящихся на
пластине.
.PP
Для решения задачи было выбрано машинное обучение. Метод, с помощью которого,
имея большое число эмпирических данных об исследуемой проблеме (в случае с
автомобильными номерами \*- это фотографии, на которых пластины с номером
находятся в естественных для них условях), можно найти способ её решения.
.PP
В первом разделе описывается, что такое машинное обучение, а также дается
значение терминов, используемых в этой работе. Остальные разделы описывают
применяемые методы, их реализацию, а также результаты их работы.
.
.
.H1 "Необходимая терминология"
.
.H2 "Машинное обучение"
.PP
Машинное обучение \*- это выявление каких-либо закономерностей по набору
эмпирических данных. Т.е. имеется какое-либо явление или объект, а также
множество данных, полученных непосредственно с него (это множество называют
\*Iобучающей выборкой\*P), требуется на основе этого множества выявить
взаимосвязи, присутствующие в данном объекте или явлении.
.PP
Машинное обучение можно разделить на \*Iобучение с учителем\*P и \*Iобучение
без учителя\*P. В первом случае к каждому примеру из обучающей выборки
прилагается ответ, который должна дать обучаемая система, исследуя его, а во
втором \*- системе дается только обучающая выборка.
.PP
Распространенным примером обучения с учителем является задача классификации, о
которой пойдет речь в следующем разделе. А как пример обучения без учителя,
можно привести задачу \*Iобнаружения выбросов\*P: поиск в обучающей выборке
небольшого числа значений, сильно отличащихся от остальных.
.
.H2 "Классификация"
.PP
Классификация \*- это задача, суть которой состоит в следующем: имеется
множество объектов (обучающая выборка), разделенное на определенные группы
(классы), по какому-либо признаку, требуется найти способ, которым можно
определить принадлежность к одному из этих классов для произвольного объекта
(классифицировать объект) того же типа, что и объекты из обучающей выборки.
По сути, задача классификации является разновидностью машинного обучения.
.PP
Как пример можно привести распознавание текста, где в качестве классов
выступают буквы, цифры, знаки препинания и все остальное (отдельный класс), а
изображения с ними \*- в качестве обучающей выборки. Тогда, чтобы
классифицировать изображение, надо определить, изображены ли на ней буква,
цифра или знак препинания, если да, то какие.
.PP
Еще одним интересным примером является проверка на наличие определенного
объекта на изображении, например, лица. В этом случае класса всего два:
изображение лица, изображение не лица. Тогда обучающая выборка будет состоять
из разных изображений, где на одних лица есть, а на других \*- нет.
Классификация изображения будет состоять в том, чтобы определить, изображено
ли на нем лицо.
.
.
.H1 "Каскад Хаара"
.PP
Каскад Хаара \*- способ обнаружения объектов на изображении, основанный на
машинном обучении, идея которого была была предложена в статье за авторством
\*IПола Виолы (Paul Viola)\*P и \*IМайкла Джонса (Michael Jones)\*P.
.PP
Обученный каскад Хаара, принимая на вход изображение, определяет, есть ли на
нем искомый объект, т.е. выполняет задачу классификации, разделяя входные
данные на два класса (есть искомый объект, нет искомого объекта). 
.PP
Правильно обученный каскад Хаара имеет хорошую скорость выполнения
классификации, а также неплохую устойчивость к разного рода отклонениям.
Изначально данный способ был предназначен для обнаружения лиц, однако его
можно использовать и для обнаружения других объектов, например, пластины с
автомобильным номером.
.
.H2 "Признаки Хаара"
.PP
Признак Хаара является набором прямоугольных областей изображения, примыкающих
друг к другу и разделенных на две группы. Возможных признаков Хаара огромное
множество (разнообразные комбинации областей разной ширины и высоты с разными
позициями на изображении). Первоначальный набор признаков зависит от реализации
и конкретной задачи. 
.sp 1.0v
.PSPIC haar_primitives.eps 16m
.ps -2
.vs -2
.ce 100
Рис. 1. Комбинации прямоугольных областей, которые использовались при
написании этой статьи.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Чтобы вычислить значение конкретного признака Хаара для какого-либо
изображения, надо сложить яркости пикселей изображения в первой и второй группах
прямоугольных областей по отдельности, а затем вычесть из первой полученной
суммы вторую. Полученная разность и есть значение конкретного признака Хаара
для данного изображения.
.sp 1.0v
.PSPIC numprim.eps 16m
.ps -2
.vs -2
.ce 100
Рис. 2. Признак Хаара на изображении.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Рис. 2 изображает пример признака Хаара на изображении: белые прямоугольники
\*- первая группа группа областей, а черный \*- вторая. Значение признака Хаара
\*- это разность сумм яркостей пикселей первой и второй группы. В
математической форме это будет выглядеть так:
.sp 1v
.EQ
a sub i = sum from {i={y sub a sub i}} to {{y sub a sub i}+{h sub a sub i}-1}
~~
sum from {j^=^{x sub a sub i}} to {{x sub a sub i}+{w sub a sub i}-1} v sub {i j}
~~~~~~~~
b sub i = sum from {i={y sub b sub i}} to {{y sub b sub i}+{h sub b sub i}-1}
~~
sum from {j^=^{x sub b sub i}} to {{x sub b sub i}+{w sub b sub i}-1} v sub {i j}
~~~~~~~~
.EN
.sp 1.0v
.EQ
h = sum from {i ^ = ^ 1} to {{N sub a}} {a sub i}
- sum from {i ^ = ^ 1} to {{N sub b}} {b sub i}
~,
.EN
.sp 1.0v
где $v sub {jk}$ \*- яркость пискеля с координатами $[j, k]$, $a sub i$ \*-
сумма яркостей пикселей в $i$-й области первой группы, $b sub i$ \*- сумма
яркостей пикселей в $i$-й области второй группы, $h$ \*- значение признака
Хаара для этого изображения, $h sub {a sub i}$, $w sub {a sub i}$,
$h sub {b sub i}$ и $w sub {b sub i}$ \*- высота и ширина $i$-х областей первой
и второй групп соответственно, $y sub {a sub i}$ и $x sub {a sub i}$,
$y sub {b sub i}$ и $x sub {b sub i}$ \*- смещения по оси $y$ и $x$ $i$-х
областей первой и второй групп, а $N sub a$ и $N sub b$ \*- количество областей
в первой и второй группы.
.
.H2 "Нормализация изображения"
.PP
Прежде чем классифицировать изображение или использовать его как пример для
обучения, это изображение следует нормализовать, т. е. привести к стандартному
виду. При использовании каскадов Хаара это означает, что надо перевести
изображение из текущей цветовой схемы в черно-белую, а также нормализовать
(сделать равным единице) его среднеквадратичное отклонение.
.PP
Следует начать с перевода изображения в черно-белую цветовую схему. Так как
обычно изображения изначально загружаются в цветовой схеме \*IRGB\*P, будет
приведена формула только для нее:
.sp 1.0
.EQ
i [ x; y ] = size -2 {{{I sub r} [ x; y ] + {I sub g} [ x; y ] + {I sub b}
[ x; y ]} over 3}
~ ,
.EN
.sp 1.0
где $i [ x; y ]$ \*- пиксель черно-белого изображения, а $I sub r [x; y]$,
$I sub g [x; y]$ и $I sub b [x; y]$ \*- соотвественно красная, синяя или
зеленая компоненты изображения.
.PP
После этого надо нормализовать среднеквадратическое отклонение. Это необходимо
для того, чтобы разница в освещенности на фотографиях оказывала минимум влияния
на результат классификации. Для этого следует вычислить среднее арифметическое
изображения по следующей формуле:
.sp 1.0
.EQ
a = {size -2 {1 over wh}} {sum from {i ^ = ^ 1} to w}
{sum from {j ^ = ^ 1} to h} {x sub ij}
~ ,
.EN
.sp 1.0
а потом найти среднеквадратическое отклонение по формуле:
.sp 1.0
.EQ
sigma = left ( {{size -2 {1 over hw}} {sum from {i ^ = ^ 1} to h}
{sum from {j ^ = ^ 1} to w} { ({x sub ij} - a) sup 2 }} right )
sup {~ {1 over 2}}
.EN
.sp 1.0
.PP
После того, как среднеквадратическое отклонение было найдено, можно его
нормализовать, поделив на него значение каждого пикселя в черно-белом
изображении:
.sp 1.0
.EQ
{x sub ij} = {size -2 {{x sub ji} over sigma}}
.EN
.sp 1.0
.PP
Теперь полученное изображение можно использовать для обучения каскада Хаара.
Также эти операции следует выполнять с изображением перед его классификацией.
.
.H2 "Интегральная форма представления изображения"
.PP
Вычисление значения каждого признака Хаара для изображения требует много
операций сложения. Однако, если использовать интегральную форму изображения,
количество вычислений можно сильно уменьшить.
.PP
В интегральной форме изображения значение каждого пикселя является суммой
яркостей этого пикселя и всех пикселей, что находятся выше и левее
него (если пиксель с координатами $[1; 1]$ находится в верхнем левом углу
изображения):
.sp 1v
.EQ
S sub {yx} = sum from {i^=^1} to {y} sum from {j^=^1} to {x} {x sub ij}
~,
.EN
.sp 1.0v
где $S sub yx$ \*- значение пикселя интегральной формы изображения с
координатами $[y; x]$, а $x sub ij$ \*- значение пикселя исходного изображения
с координатами $[i; j]$.
.PP
Переведя изображение в интегральную форму, можно вычислять значения признаков
Хаара для него, не выполняя суммирование всех требуемых значений яркостей
каждый раз по новой. Достаточно посчитать сумму яркостей для каждой
прямоугольной области, используя свойства интегральной формы изображения:
.sp 1.0v
.EQ
left { lpile {
a sub i
= S[{{y sub a sub i} + h sub a sub i};{{x sub a sub i} + w sub a sub i}]
above
a sub i
= S[{{y sub a sub i} + h sub a sub i};{{x sub a sub i} + w sub a sub i}]
- S[{{y sub a sub i} + h sub a sub i};{x sub a sub i}]
above a sub i
= S[{{y sub a sub i} + h sub a sub i};{{x sub a sub i} + w sub a sub i}]
- S[{y sub a sub i};{{x sub a sub i} + w sub a sub i}]
above a sub i
= S[{{y sub a sub i} + h sub a sub i};{{x sub a sub i} + w sub a sub i}]
- S[{y sub a sub i};{{x sub a sub i} + w sub a sub i}]
- S[{{y sub a sub i} + h sub a sub i};{x sub a sub i}]
+ S[{y sub a sub i};{x sub a sub i}]
}
lpile {
, y = 1, x = 1
above
, y > 1, x = 1
above
, y = 1, x > 1
above
, y > 1, x > 1
} right ""
.EN
.sp 1.0v
.EQ
left { lpile {
b sub i
= S[{{y sub b sub i} + h sub b sub i};{{x sub b sub i} + w sub b sub i}]
above
b sub i
= S[{{y sub b sub i} + h sub b sub i};{{x sub b sub i} + w sub b sub i}]
- S[{{y sub b sub i} + h sub b sub i};{x sub b sub i}]
above b sub i
= S[{{y sub b sub i} + h sub b sub i};{{x sub b sub i} + w sub b sub i}]
- S[{y sub b sub i};{{x sub b sub i} + w sub b sub i}]
above b sub i
= S[{{y sub b sub i} + h sub b sub i};{{x sub b sub i} + w sub b sub i}]
- S[{y sub b sub i};{{x sub b sub i} + w sub b sub i}]
- S[{{y sub b sub i} + h sub b sub i};{x sub b sub i}]
+ S[{y sub b sub i};{x sub b sub i}]
}
lpile {
, y = 1, x = 1
above
, y > 1, x = 1
above
, y = 1, x > 1
above
, y > 1, x > 1
} right ""
.EN
.sp 1.0v
где $S[y;x]$ \*- значение пикселя интегральной формы изображения. Далее можно
вычислить значение признака Хаара как обычно:
.sp 1.0v
.EQ
h = sum from {i^=^1} to {{N sub a}} {a sub i}
- sum from {i^=^1} to {{N sub b}} {b sub i}
~,
.EN
.sp 1.0v
.PSPIC imgintegral.eps 16m
.ps -2
.vs -2
.ce 100
Рис. 3. Вычисление с помощью интегральной формы изображения.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Рис. 3 иллюстрирует, что для того, чтобы вычислить сумму значений пикселей в
прямоугольнике $D$, можно использовать интегральную форму изображения: в ней
точка $a$ будет являться суммой значений пикселей в прямоугольнике $A$, точка
$b$ \*- суммой значений пикселей в прямоугольниках $A$ и $B$, точка $c$ \*-
суммой значений пикселей в прямоугольниках $A$ и $C$, а точка $d$ \*- суммой
значений пикселей в прямоугольниках $A$, $B$, $C$ и $D$. Тогда сумма значений
пикселей в прямоугольнике $D$ будет равна $d$ - $c$ - $b$ + $a$.
.
.H2 "Алгоритм AdaBoost"
.PP
Для выбора признаков, лучше всего классифицирующих изображения используется
алгоритм \*IAdaBoost\*P (adaptive boosting). Этот алгоритм построен на идее,
что из большого числа простых способов классификации (называемых \*Iслабыми
классификаторами\*P) можно составить новый способ, выполняющий эту задачу
намного эффективнее.
.PP
В данном случае слабый классификатор \*- это функция, которая принимает на вход
изображение, вычисляет значение соответствующего ей признака Хаара для этого
изображения и сравнивет это значение с порогом, возвращая либо $0$, либо $1$.
.sp 1.0v
.EQ
{h sub i}(x) = left {
lpile {
1, {p sub i}{f sub i}(x) < {p sub i}{theta sub i}
above 0, иначе
}
right ""
~,
.EN
.sp 1.0v
где $theta sub i$ \*- порог, $x$ \*- входное изображение, ${f sub i}(x)$ \*-
значение соотвествующего признака Хаара для изображения $x$, $p sub i$ \*-
направление знака неравенства\[one], а ${h sub i}(x)$ \*- слабый классификатор.
.
.FS \[one]
Принимает одно из двух значений: $1$ или $-1$. Если оно равно $1$, ничего не
меняется, если же оно равно $-1$, знак неравенства начинает работать в обратную
сторону. Такая запись используется из-за своей краткости, а так же потому,
что при реализации на некоторых архитектурах операция умножения работает
намного быстрее, чем условные операторы.
.FE
.
.PP
Данный алгоритм перебирает все возможные слабые классификаторы и выбирает те,
которые допускают меньше всего ошибок. Важная особенность алгоритма в том, что
каждому изображению из обучающей выборки соответсвует определенный вес, и после
выбора очередного слабого классификатора веса перераспределяется так, что
неверно классифицированные изображения начинают сильнее влиять на значение
ошибки.
Ниже приведен полный алгоритм:
.sp 0.5v
.RS
Входные данные:
.RS
.PI
$h sub i$ \*- $i$-й признак Хаара (из всех возможных).
.PI
$E sub i$ \*- $i$-й обучающий пример.
.PI
$y sub i$ \*- $0$, если $i$-й обучающий пример отрицательный, и $1$, если $i$-й
обучающий пример положительный.
.PI
$n$ \*- количество обучающих примеров.
.PI
$C$ \*- требуемое число признаков Хаара.
.RE
.sp 1.0v
Переменные:
.RS
.PI
$w sub i$ \*- вес, соответствующий $i$-му обучающему примеру.
.PI
$theta sub i$ и $p sub i$ \*- порог и направление знака неравенства для $i$-го
признака Хаара, дающие наименьшую ошибку.
.PI
$epsilon ({h sub i})$ \*- ошибка $i$-го слабого классификатора.
.PI
${h dot} sub i$ \*- слабый классификатор, выбранный на $i$-й итерации.
.PI
$epsilon dot$ \*- минимальное значение ошибки слабого классификатора на текущей
итерации.
.PI
$beta sub i$ \*- минимальное значение ошибки слабого классификатора на $i$-й
итерации, представленное в другой форме (для оптимизации вычислений и экономии
места на бумаге).
.RE
.sp 1.0v
.PI 1.
Инициализировать веса обучающих примеров:
.sp 1.0v
.EQ
left {
lpile {
w sub i = size -2 {1 over 2m}, если~y sub i = 0
above w sub i = size -2 {1 over 2l}, если~y sub i = 1
}
right ""
~,
.EN
.sp 1.0v
где $m$ \*- число отрицательных примеров, а $l$ \*- число положительных
примеров.
.sp 1.0v
.PI 2.
Для $t$ от $1$ до $C$:
.RS
.PI a.
Нормализовать веса обучающих примеров:
.sp 1.0v
.EQ
w sub i = size -2 {{w sub i} over {sum from {j^=^1} to n {w sub j}}}
.EN
.sp 1.0v
.PI b.
Найти для каждого признака Хаара, порог и направление знака 
неравенства такие, чтобы слабый классификатор, составленный из них дал
наименьшую ошибку:
.sp 1.0v
.EQ
{h dot}^(x) = left {
lpile {
1, {p sub j}{h sub j}(x) < {p sub j}{theta sub j}
above 0, иначе
}
right ""
~,
~~~~
epsilon ( {h sub j} ) = sum from k to n {{w sub k} left | {{h dot}^({E sub k})
- {y sub k}} right |} ~ \*- ~ минимальный 
~~
.EN
.sp 1.0v
.PI c.
Hайти классификатор с наименьшей ошибкой:
.sp 1.0v
.EQ
{epsilon ( {{h dot} sub t}} ) = min {epsilon ( {h sub j} )}
.EN
.sp 1.0v
.EQ
{{h dot} sub t} = left {
lpile {
1, {p sub n}{h sub n}(x) < {p sub n}{theta sub n}
above 0, иначе
}
right ""
~,
.EN
.sp 1.0v
где $n$ \*- номер слабого классификатора, дающего наименьшую ошибку.
.sp 1.0v
.PI d.
Обновить веса обучающих примеров:
.sp 1.0v
.EQ
beta sub t = size -2 {{epsilon ( {{h dot} sub t} ) }
over {1 - {epsilon ( {{h dot} sub t}})}}
.EN
.sp 1.0v
.EQ
w sub i = {w sub i} {beta sub t} sup {1^-^{left |{{h dot} sub t}({E sub i})^-^{y sub i} right |}}
.EN
.sp 1.0v
.RE
.PI 3.
Итоговый сильный классификатор:
.sp 1.0v
.EQ
H(x) = left { lpile {
1, ~ sum from {t = 1} to C {log ({size -2 {1 over {beta sub t}}}) {h dot} sub t}({E sub i})
>= size -2 {1 over 2} sum from {t = 1} to C {log ({size -2 {1 over {beta sub t}}})}
above
0, ~ roman "иначе"
}
right ""
.EN
.sp 1.0v
.RE
.sp 0.5v
.PP
Стоит отметить, что под "всеми возможными признаками Хаара" подразумеваются
признаки Хаара, имеющие заранее определенное взаимное расположение
прямоугольников, а также их версии, маштабированные по ширине и высоте так,
чтобы те не выходили за границы окна с заданными шириной и высотой. Все
обучающие примеры должны иметь такую же ширину и высоту, как и окно.
.PP
Полученный сильный классификатор уже способен выполнять задачу классификации,
хоть и очень медленно. Значение
${a sub i} = log {size -2 {1 over {beta sub i}}}$ далее будет рассматриваться
как "коэффициент $i$-го слабого классификатора".
.
.H2 "Быстрое вычисление наилучшего" "порога для слабого классификатора"
.PP
Перебор всех возможных признаков Хаара выполняется за приемлимое время. Однако
нахождение наилучшего порога и направления знака неравенства таким же способом
требует такого количества времени, что применение на практике каскадов Хаара
становится затруднительным (так как порог \*- число вещественое, количество его
возможных значений ограничено лишь особенностями представления вещественных
чисел на конкретной машине).
.PP
Однако, если обратить больше внимания на то, какую задачу должен выполнять
порог в слабом классификаторе, можно заметить, что перебирать все возможные
его значения нет нужды.
.PP
Если предположить, что веса всех обучающих примеров равны, то порог должен
разделять плохие и хорошие примеры по значению признака Хаара таким образом,
чтобы с одной стороны было как можно больше хороших, а с другой \*- как можно
больше плохих (какие примеры должны быть с каждой стороны, определяет
направление знака неравенства). Но так как веса обычно разные, то задачу
надо изменить так: сумма весов примеров, находящихся не по ту сторону
порога, по которую им следует находиться, должна быть минимальной.
.PP
Так как значение признака Хаара для изображения
есть обычное вещественное число, то это можно изобразить так:
.sp 1.0v
.PSPIC primvals.eps 25m
.ps -2
.vs -2
.ce 100
Рис. 4
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
На рис. 4: по горизонтальной оси расположены номера обучающих примеров, по
вертикальной \*- значения признаков Хаара для соответствующих обучающих
примеров. Зеленые точки \*- значение признака Хаара для хороших примеров,
красные точки \*- для плохих. Горизонтальная линия на графике \*- один из
возможных порогов.
.PP
Отсортировав обучающие примеры по их значению признака Хаара, можно получить
такую картинку:
.sp 1.0v
.PSPIC primvalssorted.eps 25m
.ps -2
.vs -2
.ce 100
Рис. 5
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
На рис. 5 по горизонтальной оси расположены номера обучающих примеров, по
вертикальной \*- значения признаков Хаара для соответствующих обучающих
примеров. Зеленые точки \*- значение признака Хаара для хороших примеров,
красные точки \*- для плохих.
.PP
Теперь можно заметить, что все пороги, находящиеся между двумя соседними
точками на отсортированном графике, дают одинаковые результаты. Следовательно,
чтобы получить наименьшую возможную ошибку, достаточно проверить только $n - 1$
порогов, где $n$ \*- количество обучающих примеров, беря как значение порога,
например, среднее между двумя соседними отсортированными значениями признака
Хаара.
.PP
Однако, даже после этого, перебор признаков Хаара занимает очень много времени.
Одной из причин является вычисление ошибки слабого классификатора, требующее
большое количество операций суммирования и выполняющееся огромное количество
раз.
.PP
К счастью, есть способ вычислять ошибку слабого классификатора, не выполняя
столько операций суммирования. Для этого можно использовать трюк, очень похожий
на интегральную форму представления изображения:
.sp 1.0v
.RS
.PI
$h$ \*- признак Хаара, для которого ищется порог.
.PI
$E sub i$ \*- $i$-й обучающий пример.
.PI
$y sub i$ \*- $0$, если $i$-й обучающий пример отрицательный, и $1$, если $i$-й
обучающий пример положительный.
.PI
$n$ \*- количество обучающих примеров.
.PI
$w sub i$ \*- вес, соответствующий $i$-му обучающему примеру.
.PI
$w sup +$, $w sup -$ \*- дополнительные массивы.
.PI
$theta dot$ \*- порог проверяемый на текущей итерации.
.PI
$epsilon dot$ \*- ошибка на текущей итерации.
.PI
$epsilon$ \*- наименьшая полученная ошибка, изначально равна $1$.
.PI
$theta$ и $p$ \*- значение порога и направления знака неравенства,
при которых была получена наименьшая ошибка.
.RE
.sp 1.0v
.RS
.PI 1.
Отсортировать обучающие примеры. Веса и элементы массива $y$ расположить в
таком же порядке, как и отсортированные примеры (т.е. чтобы каждому примеру
после сортировки соответствовал тот же вес и элемент из $y$, что и до
сортировки).
.PI 2.
Сделать два дополнительных массива, в первом массиве $i$-й элемент содержит
сумму весов хороших примеров до $i$-го значения, а во втором \*- плохих:
.sp 1.0v
.EQ
{w sup +} sub i = sum from {j = 1} to i {left { lpile{{w sub j},
~ roman "если" ~ {y sub j = 1} above 0, ~ roman "если" ~ {y sub j = 0} }}
.EN
.sp 1.0v
.EQ
{w sup -} sub i = sum from {j = 1} to i {left { lpile{{w sub j},
~ roman "если" ~ {y sub j = 0} above 0, ~ roman "если" ~ {y sub j = 1} }}
.EN
.sp 1.0v
.PI 3.
Для всех $i$ от $2$ до $n$:
.RS
.PI a.
Вычислить значение проверяемого порога:
.sp 1.0v
.EQ
{theta dot} = { size -2 { h ^ ( {E sub {i - 1}} ) + h ^ ( {E sub i} ) } } over 2
.EN
.sp 1.0v
.PI b. 
Посчитать ошибку для $p = 1$:
.sp 1.0v
.EQ
{epsilon dot} = {w sup -} sub {i - 1} ~ + ~ {w sup +} sub n
~ - ~ {w sup +} sub {i - 1}
.EN
.sp 1.0v
.PI c.
Если ошибка проверяемого порога меньше текущей минимальной ошибки, запомнить
этот порог, ошибку и направление знака неравенства:
.sp 1.0v
.EQ
roman "если" ~ { {epsilon dot} < epsilon },
roman "тогда" ~ { epsilon = {epsilon dot} }, { theta = {theta dot} }, {p = 1} 
.EN
.sp 1.0v
.PI d.
Посчитать ошибку для $p = - ^ 1$:
.sp 1.0v
.EQ
{epsilon dot} = {w sup +} sub {i - 1} ~ + ~ {w sup -} sub n
~ - ~ {w sup -} sub {i - 1}
.EN
.sp 1.0v
.PI e.
Если ошибка проверяемого порога меньше текущей минимальной ошибки, запомнить
этот порог, ошибку и направление знака неравенства:
.sp 1.0v
.EQ
roman "если" ~ { {epsilon dot} < epsilon },
roman "тогда" ~ { epsilon = {epsilon dot} }, { theta = {theta dot} }, {p = - ^ 1} 
.EN
.RE
.sp 1.0v
.RE
.sp 0.5v
.
.H2 "Каскад классификаторов"
.PP
Если уменьшать значение порога \*Iсильного\*P классификатора, уменьшается
количество ложных негативных срабатываний (неверно классифицированных хороших
примеров) и увеличивается количество ложных позитивных (неверно
классифицированных плохих примеров). Таким образом, даже если сильный
классификатор состоит из малого количества слабых классификаторов,
понижая порог, ценой большего числа ложных позитивных срабатываний можно свести
к минимуму количество ложных негативных.
.PP
Используя это свойство, из найденных слабых классификаторов можно составить
\*Iкаскад\*P, являющийся набором сильных классификаторов, называемых стадиями,
через которые последовательно проходит проверяемое изображение. Каждая стадия
содержит больше слабых классификаторов, чем предыдущие. После применения каждой
последующей стадии, вероятность ложного позитивного срабатывания снижается, а
вероятность ложного негативного остается маленькой.
.PP
Проверяемое изображение классифицируется положительно, только если оно дало
положительный результат на каждой стадии. Если изображение дало отрицательный
результат хотя бы на одной стадии, оно классифицируется отрицательно. Так как
на практике проверяется большое количество изображений, лишь малая часть
которых содержит искомый объект, большинство отсеивается на ранних стадиях,
состоящих из меньшего количества слабых классификаторов.
.sp 1.0v
.PSPIC cascade.eps 20m
.ps -2
.vs -2
.ce 100
Рис. 6. Иллюстрация структуры каскада.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Рис. 6 иллюстрирует структуру каскада: круги \*- это слабые классификаторы
(цифры в кругах показывают их порядковый номер), каждый ряд кругов \*- это
стадия каскада.
.PP
Построить каскад классификаторов можно добавляя к текущей стадии слабые
классификаторы и задавая нужный порог, пока доля ложных позитивных
срабатываний (отношение количества неверно классифицированных отрицательных
примеров к общему их количеству) на этой стадии больше заданного значения. Как
только доля ложных позитивных срабатываний стала меньше этого значения, надо
перейти к следующей стадии и точно также добавлять к ней слабые классификаторы.
Полный алгоритм будет выглядеть так:
.sp 0.5v
.RS
.PI
$N sub i$ \*- число слабых классификаторов на $i$-й стадии.
.PI
$THETA sub i$ \*- порог на $i$-й стадии.
.PI
$n$ \*- номер текущей стадии.
.PI
$phi$ \*- заданное наперед значение.
.PI
$p sub i$ \*- доля ложных позитивных срабатываний $i$-й стадии.
.PI
$n sub i$ \*- доля ложных негативных срабатываний $i$-й стадии.
.PI
$a sub i$ \*- коэффициент $i$-го слабого классификатора.
.RE
.sp 1.0v
.RS
.PI 1.
Установить текущей стадией первую, сделав число слабых классификаторов на ней
равным 1:
.sp 1.0v
.EQ
n = 1
.EN
.sp 0.5v
.EQ
N sub n = 1
.EN
.sp 1.0v
.PI 2.
Установить для текущей стадии такой порог, чтобы все положительные примеры
классифицировались верно:
.sp 1.0v
.EQ
roman "установить" ~ {THETA sub n}, roman "такой, что" ~ n sub n = 0
.EN
.sp 1.0v
.PI 3.
Если доля ложных позитивных срабатываний текущей стадии больше $phi$, увеличить
число слабых классификаторов на ней, в противном случае сделать текущей
следующую стадию, установив в ней число слабых классификаторов равным числу
слабых классификаторов предыдущей, увеличенному на $1$:
.sp 1.0v
.EQ
lpile {
roman "если" ~ {p sub n > phi}, roman "тогда" ~ N sub n = N sub n + 1
above
roman "иначе" ~ n = n + 1, N sub n = N sub {n - 1} + 1
}
.EN
.sp 1.0v
.PI 4.
Если число слабых классификаторов на текущей стадии меньше числа доступных
слабых классификаторов или доля ложных положительных срабатываний равна $0$,
перейти к пункту 2.
.PI 5.
Вернуть стандартный порог последней стадии, если выход из цикла произошел
из-за того, что закончились доступные слабые классификаторы:
.sp 1.0v
.EQ
roman "если" ~ {p sub n > 0}, roman "тогда" ~ THETA sub n = 
size -2 {1 over 2} sum from {i = 1} to {N sub n} {a sub i}
.EN
.RE
.sp 0.5v
.PP
Стоит заметить, что не следует использовать для построения каскада те же
хорошие примеры, что и для нахождения слабых классификаторов. Так как слабые
классификаторы слишком хорошо обучены для этих примеров, требуемая доля ложных
позитивных срабатываний будет достигнута слишком быстро. В этом случае
полученный каскад будет содержать мало стадий и начнет допускать большое
количество ошибок.
.
.H2 "Оптимизация алгоритма построения" "каскада классификаторов"
.PP
Во втором пункте указанного выше алгоритма подразумевается, что требуемый порог
ищется перебором, что на практике не очень эффективно. Как и в случае с
порогами слабых классификаторов, причиной этому являются большие затраты
времени и потери точности.
.PP
Однако, с помощью упрощенного варианта оптимизации, использовавшейся для
нахождения порогов слабых классификаторов, можно свести затраты времени на
построение каскада к минимуму.
.PP
Для того, чтобы применить этот метод, надо изменить условия, при которых порог
считается наилучшим. Также следует учесть, что у порога сильного классификатора
фиксированное направление знака неравенства ($>$).
.PP
Порог слабого классификатора считался наилучшим, если сумма весов неверно
классифицированных примеров была минимальной. В сильных же классификаторах
наилучший порог тот, при котором верно классифицируются все хорошие примеры, а
также максимальное число отрицательных.
.PP
Значение, сравниваемое с порогом сильного классификатора, является суммой
коэффициентов тех классификаторов, которые верно классифицировали входное
изображение:
.sp 1.0
.EQ
sum from {i = 1} to C { {a sub i} {h dot} sub i}(E)
~ ,
.EN
.sp 1.0
где $C$ \*- число доступных слабых классификаторов, $a sub i$ \*- коэффициент
$i$-го слабого классификатора, ${h dot} sub i$ \*- $i$-й слабый классификатор,
а $E$ \*- входное изображение.
.PP
Следовательно, чтобы все хорошие примеры были классифицированы верно,
достаточно, чтобы порог сильного классификатора был меньше такой суммы для
каждого из них. Или, если выражаться математически, порог должен быть
меньше наименьшей среди всех таких сумм для хороших примеров.
.PP
Учитывая, что чем порог ниже, тем больше плохих примеров будет
классифицировано неверно, условие стоит изменить так: порог должен быть меньше
наименьшей среди всех таких сумм для хороших примеров на наименьшее возможное
значение (в теории \*- бесконечно малое, а на практике \*- зависит от
реализации чисел с плавающей точкой на конкретной машине).
.PP
При таком условии, в отличие от порогов слабых классификаторов, не требуется
ни сортировки, ни проверки выбранного порога. Теперь можно оптимизировать
вычислениие сумм для хороших примеров. Для этого следует обратить внимание на
тот факт, что при каждой новой итерации число слабых классификаторов на текущей
стадии на $1$ больше, чем на предыдущей. Тогда вместо того, чтобы каждый раз
вычислять сумму заново, можно сделать дополнительный массив (для каждого
хорошего примера \*- соответствующий элемент массива) и при каждой итерации
добавлять туда необходимые слагаемые. Ниже приведен алгоритм с учетом всех
описанных оптимизаций:
.sp 0.5v
.RS
.PI
$C$ \*- число доступных слабых классификаторов.
.PI
${h dot} sub i$ \*- $i$-й слабый классификатор.
.PI
$C sub i$ \*- число слабых классификаторов на $i$-й стадии.
.PI
$THETA sub i$ \*- порог на $i$-й стадии.
.PI
$n$ \*- номер текущей стадии.
.PI
$phi$ \*- заданное наперед значение.
.PI
$P sub i$ \*- доля ложных позитивных срабатываний $i$-й стадии.
.PI
$g sub i$ \*- $i$-й хороший пример.
.PI
$a sub i$ \*- коэффициент $i$-го слабого классификатора.
.PI
$S sub i$ \*- $i$-я ячейка дополнительного массива, соответствующая $i$-му
хорошему примеру.
.PI
$delta$ \*- миинимальное возможное число, которое можно вычесть из уменьшаемого.
.RE
.sp 1.0v
.RS
.PI 1.
Задать каждому элементу дополнительного массива значение $0$:
.sp 1.0v
.EQ
S sub i = 0
.EN
.sp 1.0v
.PI 2.
Установить текущей стадией первую, сделав число слабых классификаторов на ней
равным 1:
.sp 1.0v
.EQ
n = 1
.EN
.sp 0.5v
.EQ
C sub n = 1
.EN
.sp 1.0v
.PI 3.
Для всех хороших примеров: если последний классификатор текущей стадии
классифицировал пример верно, прибавить коэффициент этого классификатора к
значению в соответствующей примеру ячейке дополнительного массива:
.sp 1.0v
.EQ
{S sub i} = {S sub i} + {h dot} sub {C sub n} ({g sub i})
.EN
.sp 1.0v
.PI 4.
Задать порогу текущей стадии такое значение, меньшее наименьшего элемента
дополнительного массива на минимально возможное число:
.sp 1.0v
.EQ
{THETA sub i} = min ({S sub i}) - delta
.EN
.sp 1.0v
.PI 5.
Если доля ложных позитивных срабатываний текущей стадии больше $phi$, увеличить
число слабых классификаторов на ней, в противном случае сделать текущей
следующую стадию, установив в ней число слабых классификаторов равным числу
слабых классификаторов предыдущей, увеличенному на $1$:
.sp 1.0v
.EQ
lpile {
roman "если" ~ {P sub n > phi}, roman "тогда" ~ C sub n = C sub n + 1
above
roman "иначе" ~ n = n + 1, C sub n = C sub {n - 1} + 1
}
.EN
.sp 1.0v
.PI 6.
Если число слабых классификаторов на текущей стадии меньше числа доступных
слабых классификаторов или доля ложных положительных срабатываний равна $0$,
перейти к пункту 2.
.PI 7.
Вернуть стандартный порог последней стадии, если выход из цикла произошел
из-за того, что закончились доступные слабые классификаторы:
.sp 1.0v
.EQ
roman "если" ~ {P sub n > 0}, roman "тогда" ~ theta sub n = 
size -2 {1 over 2} sum from {i = 1} to {C sub n} {a sub i}
.EN
.RE
.sp 0.5v
.H2 "Поиск объектов на большом изображении"
.PP
Обученный каскад Хаара может классифицировать только изображения того
же размера, что и обучающие примеры. Для того чтобы искать объекты на большом
изображении, надо по отдельности классифицировать части этого изображения. Для
этого используется окно, двигаемое по изображению, размеры которого
соотвествуют рабочим размерам каскада. Если какая-либо часть изображения была
классифицирована положительно, значит в ней изображен искомый объект.
.PP
Также следует построить несколько маштабированных вариантов изображения,
называемых пирамидой изображений, и тоже пройтись по ним окном. Это необходимо
потому, что изображение искомого объекта совсем необязательно будет того же
размера, что и примеры из обучающей выборки. 
.PSPIC imagepyramid.eps 35m
.ps -2
.vs -2
.ce 100
Рис. 7. Пример пирамиды изображений: размер сторон каждой следующей версии
изображения равняется $0.75$ размера сторон предыдущего.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.
.H2 "Многопоточное сканирование пирамиды изображений"
.PP
Сканирование изображения каскдом Хаара, даже с учетом всех оптимизаций \*-
достаточно затратная для процессора задача. Тем не менее, чтобы обнаружать
автомобильные номера в реальном времени, оно должно выполняться достаточно
быстро \*- как минимум, несколько раз в секунду. Этого можно достичь благодаря
одной важной особенности современных процессоров, а именно, многопоточности.
.PP
Под многопоточностью подразумевается способность процессора выполнять несколько
задач одновременно. Процессор, обладающий такой особенностью, называется
\*Iмногоядерным\*P. Такой процессор, по сути представляет из себя несколько
обычных процессоров, называемых ядрами, которые соединены вместе. Каждое
ядро выполняет свою задачу независимо от других.
.PP
Чтобы многоядерный процессор мог задействовать максимум ресурсов, поставленную
ему задачу необходимо разделить на несколько более простых заданий, которые
можно выполнять независимо друг от друга. Такие задания иногда называют
\*Iпотоками\*P или \*Iнитями\*P.
.PP
С разделением задачи на потоки (\*Iраспараллеливанием\*P) связано множество
разнообразных проблем, которые могут поставить под вопрос целесообразность
распараллеливания задачи.
.PP
Во-первых, после разделения алгоритм может сильно усложниться, поэтому, оно
должно выполняться только после того, как первоначальный алгоритм был доведен
до рабочего состояния.
.PP
Во-вторых, создание потоков и обработка результатов их работы тоже требуют
ресурсов и могут свести на "нет" весь получаемый прирост производительности.
Этого можно избежать, если распараллеливать задачу так, чтобы потоки как можно
дольше могли выполняться независимо.
.PP
В-третьих, выполнение задачи будет окончено только тогда, когда будут
завершены все потоки. Поэтому, если какие-либо потоки завершат свою работу
раньше других, часть ресурсов процессора будет простаивать. По этой причине
следует разделять задачу так, чтобы все потоки выполняли свою работу примерно
за одно время.
.PP
И в-четвертых, может потребоваться, чтобы потоки совместно использовали
какие-либо данные, к которым одновременно получить доступ может только один
поток. Из-за этого возникает проблема, когда потоки подолгу ждут освобождения
доступа к каким либо данным. Также, как и предыдущая проблема, это может
сделать распараллеливание бессмысленным. Что бы избежать подобной проблемы,
следует разделять задачу так, чтобы как можно больше данных могло
использоваться независимо.
.PP
К счастью, при распараллеливании алгоритма сканирования пирамиды изображений,
большей части этих проблем можно избежать. Для этого следует обратить внимание
на структуру пирамиды:
.sp 1.0v
.PSPIC pyrwh.eps 32m
.ps -2
.vs -2
.ce 100
Рис. 8. Пирамида изображений, где ширина и высота каждого изображения
составляют 0.9 ширины и высоты предыдущего изображения.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Можно заметить, что каждый масштабированный вариант оригинала, по сути,
является отдельным изображением, которое можно сканировать независимо от
остальных.  Исходя из этого, задачу сканирования пирамиды изображений можно
разделить на определенное количество потоков, каждый из которых сканирует свою
группу уменьшенных копий.
.PP
Также, видно, что для того, что бы построить какое-либо изображение
пирамиды, не обязательно строить предыдущее. Это следует из того, что
масштабирование является умножением ширины и высоты изображения на число,
меньшее единицы, называемым коэффициентом масштабирования, с последующей
интерполяцией. Так как в данном случае это число не меняется
(на рис. 8 \*- это $0.9$), ширину и высоту любого изображения пирамиды можно
получить с помощью формулы:
.sp 1.0v
.EQ
lpile {
w sub n = d sup n w
above
h sub n = d sup n h
}
~ ,
.EN
.sp 1.0v
где $w sub n$ и $h sub n$ \*- ширина и высота $n$-го изображения пирамиды,
n \*- номер изображения в пирамиде ($0$ \*- это оригинальное изображение),
d \*- коэффициент масштабирования, а $w$ и $h$ \*- ширина и высота
оригинального изображения.
.PP
Для интерполяции, о которой речь пойдет позже, требуется только ширина и высота
входного и выходного изображений. В нашем случае входное изображение \*- это
оригинал, а выходное \*- искомая масштабированная копия. Иначе говоря, для
интерполяции, так же как и для вычисления ширины и высоты, не требуется
предыдущих изображений, за исключением оригинального.
.PP
Так как ширина и высота сканируемого изображения не могут быть меньше ширины и
высоты окна, то из предыдущей форумулы можно определить номер уменьшенной копии
минимально возможного размера:
.sp 1.0v
.EQ
n = left [ {{log sub d}
max left ( {{w sub w} over w , {h sub w} over h } right )} right ]
~ ,
.EN
.sp 1.0v
где $n$ \*- номер наименьшего изображения из пирамиды, $d$ \*- коэффициент
масштабирования, $w sub w$ и $h sub w$ \*- ширина и высота окна, а $w$ и $h$
\*- ширина и высота оригинального изображения. Квадратные скобки обозначают
взятие целой части.
.PP
Используя написанные выше формулы можно разделить изображения из пирамиды на
группы так, чтобы сканирование всех групп требовало примерно одинакового
количества ресурсов процессора и времени. Информацию о том, к какой группе
принадлежит каждое изображение, можно хранить в таблице (двумерном массиве),
где каждой группе соответствует своя строка, а в ячейках хранятся номера
изображений в пирамиде. Далее такая таблица будет называться \*Iкартой
потоков\*P.
.PP
Так как объем вычислений при сканировании зависит от количества пикселей в
изображении, то это количество можно использовать как оценку необходимых для
сканирования ресурсов (оценка сложности изображения):
.sp 1.0v
.EQ
delta sub n = w sub n h sub n
~ ,
.EN
.sp 1.0v
где $delta sub n$ \*- оценка сложности $n$-го изображения, а $w sub n$ и
$h sub n$ \*- ширина и высота $n$-го изображения пирамиды.
.PP
Однако, так как ширина и высота всех изображений одинакого зависят от ширины и
высоты оригинального изображения, оценку можно записать так:
.sp 1.0v
.EQ
delta sub n = d sup {2 n}
.EN
.sp 1.0v
где $delta sub n$ \*- оценка сложности сканирования $n$-го изображения, а $d$
\*- коэффициент масштабирования.
.PP
Для краткости назовем сумму оценок сложности изображений в группе \*Iоценкой
сложности группы\*P. Теперь задачу разделения изображений пирамиды на группы
можно сформулировать так:  сумма оценок сложности всех групп должна быть
примерно одинаковой. Так как оптимальное решение этой задачи, скорее всего,
будет достаточно сложным, лучше найти решение, близкое к оптимальному,
используя особенности пирамиды изображений.
.PP
Для начала нужно найти "идеальную" оценку сложности группы. Т.е. оценку в том
случае, если бы она была одинакова для всех групп. Получить ее можно разделив
общую сумму оценок сложности изображений на требуемое количество потоков.
.sp 1.0v
.EQ
delta = size -2 {{sum from {i = 0} to n {d sup 2i}} over T}
.EN
.sp 1.0v
где $delta$ \*- "идеальная" оценка сложности группы, $d$ \*- коэффициент
масштабирования, а $n$ \*- общее количество изображений в пирамиде.
.PP
Теперь можно по очереди заполнять каждую группу. Для этого в заполняемую
группу по очереди добавляются изображения так, чтобы её оценка не стала выше
"идеальной". Понятно, что вероятность получить оптимальное решение таким
способом очень маленькая. Однако можно выбрать такой порядок добавления
изображений, чтобы получить приемлимое решение.
.PP
Оценки сложности изображений можно представить в виде отрезков, длина которых
соответствует их значениям:
.sp 1.0v
.PSPIC estimationseg.eps 16m
.ps -2
.vs -2
.ce 100
Рис. 9. Оценки сложности изображений в виде отрезков.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Тогда составленные из них большие отрезки будут соответствовать группам
изображений. В таком виде задача будет выглядеть так: составить из данных
отрезков требуемое количество больших отрезков таким образом, чтобы длина этих
больших отрезков была примерно одинаковой. Длина "идеального" отрезка в таком
случае будет являться суммой длин всех данных отрезков, делённой на требуемое
количество больших.
.PP
Можно заметить что более длинные отрезки, стоящие в начале, удобно дополнять
более короткими, стоящими в конце, так чтобы их длина стала как можно ближе к
длине "идеального" отрезка, при этом не превысив её.
.sp 1.0v
.PSPIC estimationbigseg.eps 20m
.ps -2
.vs -2
.ce 100
Рис. 10. Пример разделения изображений на $8$ групп. Первым изображен идеальный
отрезок. Ниже изображены большие отрезки, на которых отмечены границы малых
отрезков, из которых они составлены.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
На основе этого можно вывести способ добавления изображений в группу: берется
первое неиспользованное изображение из начала, а затем к нему последовательно
добавляются неиспользованные изображения с конца, так, чтобы оценка группы
оставалась меньше "идеальной" оценки. Полный алгоритм можно записать следующим
образом:
.sp 0.5v
.RS
.PI
$n$ \*- номер последнего значения в пирамиде
.PI
$delta$ \*- "идеальная" оценка
.PI
$b$ \*- индекс начала пирамиды
.PI
$e$ \*- индекс конца пирамиды
.PI
$T$ \*- требуемое количество количество групп изображений
.PI
$t$ \*- количество построенных групп изображений
.PI
$c$ \*- текущее количество изображений в группе
.PI
$M [i] ^ [j]$ \*- номер j-го изображения в i-й группе
.PI
S \*- вспомагательная сумма
.RE
.sp 0.5v
.RS
.PI 1.
Вычислить номер последнего значения в пирамиде:
.sp 0.5v
.EQ
n = left [ {{log sub d}
max left ( {{w sub w} over w , {h sub w} over h } right )} right ]
.EN
.sp 0.5v
.PI 2.
Вычислить "идеальную" оценку:
.sp 0.5v
.EQ
delta = size -2 {{1 - d sup 2i} over {T (1 - d)}}
.EN
.sp 0.5v
.PI 3.
Инициализировать текущие индексы начала и конца пирамиды, а также текущее
количество групп:
.sp 0.5v
.EQ
pile {
b = 0 ^ , ~ e = n
above
t = 0
}
.EN
.sp 0.5v
.PI 4.
Пока $b < e$:
.RS
.PI a. 
Инициализировать текущее количество изображений в группе:
.sp 0.5v
.EQ
c = 0
.EN
.sp 0.5v
.PI b.
Добавить первое неиспользованное изображение в карту потоков:
.sp 0.5v
.EQ
pile {
M [t] ^ [c] = b
above
c = c + 1
above
b = b + 1
}
.EN
.sp 0.5v
.PI c.
Инициализировать вспомогательную сумму:
.sp 0.5v
.EQ
S = d sup b
.EN
.sp 0.5v
.PI d.
Пока $S + d sup e < delta$ и $b < e$:
.RS
.PI
I. Добавить изображение с конца пирамиды к карте:
.sp 0.5v
.EQ
pile {
M [t] ^ [c] = e
above
c = c + 1
above
e = e - 1
}
.EN
.sp 0.5v
.PI
II. Прибавить оценку добавленного изображения к вспомагательной сумме:
.sp 0.5v
.EQ
S = S + d sup {e - 1}
.EN
.sp 0.5v
.RE
.PI e.
Обозначить конец группы изображений:
.sp 0.5v
.EQ
pile {
M [t] ^ [c] = -1
above
c = c + 1
}
.EN
.sp 0.5v
.PI f.
Увеличить количество групп изображений:
.sp 0.5v
.EQ
t = t + 1
.EN
.RE
.RE
.sp 0.5v
Используя полученную карту можно сканировать изображение в несколько потоков:
.sp 0.5v
.RS
.PI
$M sub i$ \*- строка карты потоков, обрабатываемая $i$-м потоком.
.PI
$N$ \*- количество строк в карте потоков.
.PI
$r sub i$ \*- массив координат прямоугольных областей, в которых $i$-м потоком
был обнаружен искомый объект.
.PI
$R$ \*- массив, являющийся объединением всех $r sub i$.
.PI
$I sub i$ \*- текущая масштабированная копия в $i$-м потоке.
.RE
.sp 0.5v
В $i$-м потоке:
.sp 0.5v
.RS
.PI 1.
Инициализировать $j$, сделав его равным $0$
.sp 0.5v
.PI 2.
Пока $M sub i ^ [j] >= 0$:
.RS
.PI a.
Масштабировать оригинальное изображение с коэффициентом $M sub i ^ [j]$,
сохранив результат в $I sub i$.
.PI b.
Сканировать $I sub i$, помещая координаты прямоугольных областей, где был
обнаружен искомый объект в массив $r sub i$.
.PI c.
Увеличить $j$ на $1$.
.RE
.RE
.sp 0.5v
Запуск потоков и обработка результатов:
.sp 0.5v
.RS
.PI 1.
Запустить $N$ потоков. Каждый поток обрабатывает свою строку карты потоков.
.PI 2.
Ждать заверщения работы всех потоков.
.PI 3.
Объединить все массивы $r sub i$ в один массив R.
.PI 4.
Выполнить объединение пересекающихся прямоугольников в R.
.RE
.sp 0.5v
.
.H2 "Масштабирование изображений"
.PP
При построении пирамиды изображений строятся масштабированные копии
оригинального изображения. Это делается с помощью билинейной интерполяции,
которая является вариантом линейной интерполяции для функции с двумя
переменными.
.PP
Линейная интерполяция \*- это способ нахождения приближенного значения функции
в точке, находящейся между двумя другими точками, в которых значение этой
функции известно. Приближение выполняется с помощью линейной функции, откуда и
следует название. Выглядит это следующим образом:
.sp 0.5v
.EQ
f(x) = f({x sub 0}) + size -2 {{f({x sub 1})
- f({x sub 0})} over {x sub 1 - x sub 0}} ({x - x sub 0})
~ ,
.EN
.sp 0.5v
где $x$ \*- точка, в которой ищется значение функции, $f(x)$ \*- функция,
значение которой ищется в точке x, $x sub 0$ \*- точка слева от $x$, $x sub 1$
\*- точка справа от $x$.
.sp 1.0v
.PSPIC linearinterp.eps 15m
.ps -2
.vs -2
.ce 100
Рис. 11. Линейная интерполяция.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Таким образом, по сути, строится прямая, проходящая через точки на плоскости
$({x sub 0} ; f({x sub 0}))$ и $({x sub 1} ; f({x sub 1}))$, а затем с помощью
известной $x$-координаты находится $y$-координата соответствующей точки,
лежащей на этой прямой. Эта $y$-координата и будет являться искомым значением
функции в точке.
.PP
Понятно, что такое приближение может быть неточным, однако, когда точки с
известными значениями функции находятся достаточно близко, ошибка становится
незначительной. В случае масштабирования изображения для дальнейшего
распознавания компьютером, эта ошибка находится в допустимых пределах.
.PP
При билинейной интерполяции требуется найти значение функции в точке на
плоскости при известных значениях этой функции в четырех других точках на
плоскости, являющихся углами прямоугольника. Для этого интерполяция выполняется
три раза: сначала два раза по оси $x$, и затем один раз по оси $y$, где в
качестве известных значений функции уже используются результаты первых двух
интерполяций:
.sp 0.5v
.EQ
f({x ; y sub 0}) = f({x sub 0 ; y sub 0}) + size -2 {{f({x sub 1 ; y sub 0})
- f({x sub 0 ; y sub 0})} over {x sub 1 - x sub 0}} ({x - x sub 0})
.EN
.sp 0.5v
.EQ
f({x ; y sub 1}) = f({x sub 0 ; y sub 1}) + size -2 {{f({x sub 1 ; y sub 1})
- f({x sub 0 ; y sub 1})} over {x sub 1 - x sub 0}} ({x - x sub 0})
.EN
.sp 0.5v
.EQ
f(x; y) = f({x ; y sub 0}) + size -2 {{f({x ; y sub 1})
- f({x ; y sub 0})} over {y - y sub 0}} ({y - y sub 0})
~ ,
.EN
.sp 0.5v
где $(x; y)$ \*- точка, значение функции в которой ищется, $f(x; y)$ \*-
искомое значение функции в точке $(x; y)$, а $({x sub 0 ; y sub 0}$),
$({x sub 1 ; y sub 0})$, $({x sub 0 ; y sub 1})$, $({x sub 1 ; y sub 1})$ \*-
координаты точек, в которых значения функции известны.
.sp 1.0v
.PSPIC bilinearinterp.eps 15m
.ps -2
.vs -2
.ce 100
Рис. 12. Билинейная интерполяция. Для удобства поверхность функции двух
переменных
изображена "сверху".
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Чтобы построить масштабированную копию изображения, сначала вычисляется её
ширина и высота. Затем для каждого пикселя этой копии вычисляются его
координаты на оригинальном изображении. Далее с помощью этих координат
находится яркость этого пикселя (в случае, когда компонент цвета несколько \*-
значение каждой компоненты ищется отдельно).
.sp 1.0v
.PSPIC copy_orig.eps 30m
.ps -2
.vs -2
.ce 100
Рис. 13. Координаты пикселя копии на оригинальном изображении. Слева \*- копия,
справа \*- оригинальное изображение.
.ce 0
.ps +2
.vs +2
.sp 1.0v

.PP
Так как нет гарантии, что вычисленные координаты будут целыми, и таким образом
будут соответствовать конкретному пикселю, выполняется билинейная интерполяция
между четырьмя ближайшими к этим координатам пикселями оригинального
изображения. В качестве значения функции выступает яркость. Точка, где это
значение ищется \*- это координаты пикселя копии на оригинальном изображении. А
в качестве точек, где это значение известно выступают четыре ближайших к этим
координатам пикселя оригинального изображения.
.PP
При интерполяции координаты этих четырех пикселей полагаются равными $(0 ; 0)$,
$(1 ; 0)$, $(0 ; 1)$ и $(1 ; 1)$, а координаты пикселя копии на оригинальном
изображении заменяются своей дробной частью. Это упрощает формулы,
использующиеся при билинейной интерполяции, при этом не меняя результата:
.sp 0.5v
.EQ
f({x ; 0}) = f({0 ^ ; 0}) + (f({1 ; 0}) - f({0 ^ ; 0})) x
.EN
.sp 0.5v
.EQ
f({x ; 1}) = f({0 ^ ; 1}) + (f({1 ; 1}) - f({0 ^ ; 1})) x
.EN
.sp 0.5v
.EQ
f(x, y) = f({x ; 0}) + (f({x ; 1}) - f({x ; 0})) y
~ ,
.EN
.sp 0.5v
где $(x; y)$ \*- точка, значение функции в которой ищется, $f(x; y)$ \*- точка в
которой ищется значение функции, а $({0 ^ ; 0}$), $({1 ; 0})$, $({0 ^ ; 1})$,
$({1 ; 1})$ \*- координаты точек, в которых значения функции известны.
.PP
Полностью алгоритм масштабирования изображения с одной компонентой цвета будет
выглядеть так:
.sp 0.5v
.RS
.PI
$w sub 0$ и $h sub 0$ \*- ширина и высота оригинального изображения.
.PI
$w sub 1$ и $h sub 1$ \*- ширина и высота оригинального изображения.
.PI
$d sub x$ и $d sub y$ \*- коэффициенты масштабирования по осям $x$ и $y$.
.PI
$V sub 0 ^ [x ; y]$ \*- яркость пикселя оригинального изображения с
координатами $[x ; y]$
.PI
$V sub 0 ^ [x ; y]$ \*- яркость пикселя масштабированной копии с координатами
$[x ; y]$.
.PI
$x sub 0$ и $y sub 0$ \*- координаты пикселя копии на оригинальном изображении.
.PI
$p sub 0$ и $p sub 1$ \*- результаты интерполяции по оси $x$.
.RE
.sp 0.5v
.RS
.PI 1.
Вычислить ширину и высоту масштабированной копии:
.sp 0.5v
.EQ
w sub 1 = roman "ceil" ( d sub x w sub 0 )
.EN
.sp 0.5v
.EQ
h sub 1 = roman "ceil" ( d sub y h sub 0 )
.EN
.PI 2.
Для всех $y sub 1$ от $0$ до $h sub 1$:
.RS
.PI
Для всех $x sub 1$ от $0$ до $w sub 1$:
.RS
.PI a.
Вычислить координаты пикселя копии на оригинальном изображении:
.sp 0.5v
.EQ
x sub 0 = size -2 {{x sub 1} over {d sub x}}
~,
y sub 0 = size -2 {{y sub 1} over {d sub y}}
.EN
.sp 0.5v
.PI b.
Выполнить интерполяцию по оси $x$:
.sp 0.5v
.EQ
rpile {
p sub 0 = (V sub 0 ^ [ roman "floor" ( x sub 0 ) ; roman "floor" ( y sub 0 ) ]
- V sub 0 ^ [ roman "ceil" ( x sub 0 ) ; roman "floor" ( y sub 0 ) ])
(x sub 1 - roman "floor" ( x sub 1 ) )
above
+ V sub 0 ^ [ roman "floor" ( x sub 0 ) ; roman "floor" ( y sub 0 ) ]
}
.EN
.sp 0.5v
.EQ
rpile {
p sub 0 = (V sub 0 ^ [ roman "floor" ( x sub 0 ) ; roman "ceil" ( y sub 0 ) ]
- V sub 0 ^ [ roman "ceil" ( x sub 0 ) ; roman "ceil" ( y sub 0 ) ])
(x sub 1 - roman "floor" ( x sub 1 ) )
above
+ V sub 0 ^ [ roman "floor" ( x sub 0 ) ; roman "ceil" ( y sub 0 ) ]
}
.EN
.sp 0.5v
.PI c.
Выполнить интерполяцию по оси $y$:
.sp 0.5v
.EQ
V sub 1 ^ [ x sub 1 ; y sub 1 ] = ( p sub 1 - p sub 0 )
(y - roman "floor" ( y )) + p sub 0
.EN
.sp 0.5v
.RE
.RE
.RE
.PP
Функция $roman "floor"$ \*- округление в меньшую сторону, $roman "ceil"$ \*- в
большую, а $roman "frac"$ \*- взятие дробной части. Такие обозначения приняты
для удобства. Чтобы масштабировать изображение, где больше одной цветовой
компоненты, необходимо выполнить билинейную интерполяцию для каждой цветовой
компоненты пикселя по отдельности.
.
.H2 "Объединение пересекающихся прямоугольников"
.PP
Так как каскад Хаара имеет достаточно неплохую устойчивость к маштабированию
и смещению, после полного прохода по изображению и его маштабированным
вариантам искомый объект будет выделен окном несколько в соседних позициях и
маштабах.
.sp 1.0v
.PSPIC manywindows.eps 16m
.ps -2
.vs -2
.ce 100
Рис. 14. Пример выделения объекта после полного прохода окном по изображению:
зелеными прямоугольниками выделены области, изображение в которых было
классифицировано положительно.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Чтобы исправить эту проблему, был выбран следующий подход: все прямоугольники
разбиваются на группы. Прямоугольник, принадлежащий какой-либо группе
пересекается хотябы с одним из других прямоугольников этой же группы. После
этого каждая группа заменяется одним прямоугольником, являющимся усереднением
всех прямоугольников этой группы.
.PP
Задачу объединения прямоугольников в группы можно хорошо описать и решить с
помощью понятий из теории графов. Прямоугольники можно считать вершинами графа.
Если они пересекаются, можно считать что они соединены ребром. Тогда если
разбить граф на компоненты связности, вершины принадлежащие одной и той же
компоненте и будут представлять из себя искомые группы.
.PP
Сначала надо представить набор прямоугольников в виде графа. Для этого
прямоугольники нумерются. Также каждому прямоугольнику в соотвествие ставится
список, содержащий номера других прямоугольников, пресекающих его. Полученные
списки и будут преставлять из себя граф. Построить эти списки можно по
следующему алгоритму:
.sp 0.5v
.RS
.PI
$r sub i$ \*- $i$ \*-й прямоугольник.
.PI
$N$ \*- количество имеющихся прямоугольников.
.PI
$e sub ij$ \*- номер (в $r sub i$) $j$-го прямоугольника из тех, которые
пересекаются с $i$-м прямоугольником.
.PI
$N sub i$ \*- количество прямоугольников, пресекающихся с $i$-м
прямоугольником. Изначально равно нулю.
.RE
.sp 1.0v
.RS
.PI
Для всех i и j от $0$ до $N$:
.RS
.PI
Если прямоугольники $r sub i$ и $r sub j$ пересекаются, добавить в список,
соответствующий вершине $r sub i$ значение  $j$:
.sp 0.5v
.EQ
roman "если" ~ r sub i , ~ r sub j ~ roman "пересекаются, тогда"
~ e sub {i {N sub i}} = j
.EN
.sp 0.5v
.EQ
N sub i = N sub i + 1
.EN
.RE
.RE
.sp 0.5v
.PP
Проверка пересечения двух прямоугольников выполняется с помощью проекций на
оси. То есть, проверяются на пересечение их проекций на ось $X$ и на ось $Y$ по
отдельности. Если пересечение имеется при проекций на обе оси, то
прямоугольники пересекаются. Проверка пересечений проекций выполняется
следующим образом:
.sp 0.5v
.RS
.PI
$A sub x0$, $A sub y0$ \*- наименьшие координаты угла первого прямоугольника.
.PI
$A sub x1$, $A sub y1$ \*- наибольшие координаты угла первого прямоугольника.
.PI
$B sub x0$, $B sub y0$ \*- наименьшие координаты угла второго прямоугольника.
.PI
$B sub x1$, $B sub y1$ \*- наибольшие координаты угла второго прямоугольника.
.RE
.sp 0.5v
.EQ
roman "если" ~ A sub x0 > B sub x1 ~ roman "или" ~ A sub x1 < B sub x0, ~
roman "то проекции на ось" ~ X ~ roman "пересекаются"
.EN
.sp 0.5v
.EQ
roman "если" ~ A sub y0 > B sub y1 ~ roman "или" ~ A sub y1 < B sub y0, ~
roman "то проекции на ось" ~ Y ~ roman "пересекаются"
.EN
.sp 0.5v
.PP
После этого требуется разбить полученный граф на компоненты связности. Если
точнее, требуется узнать, к какой компоненте относится каждая вершина.
Информация о ребрах внутри этих компонент, не требуется. Исходя из этого можно
использовать следующий алгоритм:
.sp 0.5v
.RS
.PI
$r sub i$ \*- соответствует $i$-й вершине. Если равен 1, то эта вершина была
достигнута из выбранной начальной вершины.
.PI
$R sub i$ \*- соответствует $i$-й вершине. Если равен 1, то эта вершина уже была
достигнута из другой вершины. Изначально равен $0$.
.PI
$V sub i$ \*- количество вершин, в $i$-й компоненте связности. Изначально равно
нулю.
.PI
$с sub ij$ \*- номер $j$-й вершины в $i$-й компоненте связности.
.PI
$C$ \*- количество компонент связности. Изначально равно нулю.
.PI
$e sub ij$ \*- номер $j$-й вершины из тех, в которые можно
попасть из $i$-й вершины.
.PI
$E sub i$ \*- количество вершин, в которые можно попасть из $i$-й вершины.
.PI
$n$ \*- номер вершины, с которой начинается выделение компоненты связности.
Изначально равен нулю.
.PI
$v$ \*- $i$-я вершина.
.PI
$N$ \*- общее количество вершин.
.RE
.sp 1.0v
.RS
Пока $n < N$:
.RS
.PI 1.
Обнулить $r sub i$:
.sp 0.5v
.EQ
roman "для всех" ~ i ~ roman "от" ~ 0 ~ roman "до" ~ N - 1 : r sub i = 0
.EN
.sp 0.5v
.PI 2.
Отметить все вершины, которые можно достигнуть из текущей вершины:
.sp 0.5v
.EQ
roman "если из вершины" ~ v sub n ~ roman "можно достигнуть вершину" ~ v sub i
, ~ roman "то" ~ r sub i = 1, ~ R sub i = 1
.EN
.sp 0.5v
.PI 3.
Добавить все отмеченные на текущем шаге вершины в новую компоненту связности:
.sp 0.5v
.EQ
roman "для всех" ~ i ~ roman "от" ~ 0 ~ roman "до" ~ N - 1 : ~ roman "если" ~
r sub i = 1 , ~ roman "тогда" ~ c sub {C {V sub C}} = i ,
~ V sub C = V sub C + 1
.EN
.sp 0.5v
.EQ
C = C + 1
.EN
.sp 0.5v
.PI 4.
Найти вершину с которой начнется выделение следующей компоненты связности:
.sp 0.5v
.EQ
roman "пока" ~ R sub n = 1 ~ roman "и" ~ n < N : ~ n = n + 1, 
.EN
.sp 0.5v
.RE
.RE
.sp 0.5v
.PP
Нахождение всех вершин, которые можно достигнуть из текущей выполняется простым
проходом по графу и отметкой уже пройденных вершин. В развернутом виде пункт 2.
будет выглядеть так:
.sp 1.0v
.RS
.PI 1.
Отметить вершину с номером $n$:
.sp 0.5v
.EQ
r sub n = 1
, ~
R sub n = 1
.EN
.sp 0.5v
.PI 2.
Перейти по всем ребрам вершины с номером $n$:
.sp 0.5v
.EQ
roman "для всех" ~ j ~ roman "от" ~ 0 ~ roman "до" ~ E sub i - 1 : ~
roman "если" ~ r sub {e sub ij} != 1,
roman "перейти к пункту 1. сделав" ~ n = e sub ij
.EN
.RE
.sp 1.0v
.PP
После того, как было определенно, к какой компоненте связности относится каждая
вершина, любую группу пересекающихся прямоугольников можно заменить одним
усередненным прямоугольником.
.PP
В качестве усередненния используется прямоугольник, чьи наименьшие и
наибольшие координаты угла находятся как среднее арифметическое наименьших и
наибольших координат угла всех прямоугольников группы:
.sp 0.5v
.RS
.PI
$C$ \*- количество компонент связности.
.PI
$c sub i$ \*- количество прямоугольников в $i$-й компоненте связности.
.PI
$r sub {ij}$ \*- номер $j$-й вершины в $i$-й компоненте связности.
.PI
$x0 sub i$ , $y0 sub i$ , $x1 sub i$ , $y1 sub i$ \*- минимальные и
максимальные $x$ и $y$ координаты углов усередненного прямоугольника,
соответствующего $i$-й компоненте связности.
.PI
$x0 sub {ij}$ , $y0 sub {ij}$ , $x1 sub {ij}$ , $y1 sub {ij}$ \*- минимальные и
максимальные $x$ и $y$ координаты углов прямоугольника, соответствующего $j$-у
прямоугольнику в $i$-й компоненте связности.
.RE
.sp 1.0v
.RS
Для всех i от $0$ до $n$:
.RS
.PI 1.
Установить координаты углов усередненного прямоугольника,
соответствующего $i$-й компоненте связности в $0$:
.sp 0.5v
.EQ
x0 sub i = 0 ^ , ~ y0 sub i = 0 ^ , ~ x1 sub i = 0 ^ , ~ y1 sub i = 0
.EN
.sp 0.5v
.PI 2.
Для всех $j$ от $0$ до $c sub i$:
.RS
.PI
Прибавить к координатам углов усередненного прямоугольника,
соответствующего $i$-й компоненте связности, координаты углов $j$-го
прямоугольника этой компоненты связности: 
.sp 0.5v
.EQ
lpile {
x0 sub i = x0 sub i + x0 sub {ij}
above
y0 sub i = y0 sub i + y0 sub {ij}
above
x1 sub i = x1 sub i + x1 sub {ij}
above
y1 sub i = y1 sub i + y1 sub {ij}
}
.EN
.sp 0.5v
.RE
.PI 3.
Поделить координаты углов усередненного прямоугольника, на количество
прямоугольников в $i$ компоненте связности:
.sp 0.5v
.EQ
lpile {
x0 sub i = size -2 {{x0 sub i} over {c sub i}} ,
~ y0 sub i = size -2 {{y0 sub i} over {c sub i}}
above
x1 sub i = size -2 {{x1 sub i} over {c sub i}} ,
~ y1 sub i = size -2 {{y1 sub i} over {c sub i}}
}
.EN
.sp 1.0v
.RE
.RE
.
.
.H1 "Исправление искажений перспективы"
.PP
После того, как область, в которой находится пластина с автомобильным номером,
была выделена, ее следует привести к виду, пригодному для распознаванию
отдельных символов на этой пластине. Одна из основных проблем, мешающих
корректному распознаванию символом \*- это искажения перспективы, возникающие
когда номер снимается не под прямым углом.
.PP
Для решения этой проблемы используется комбинация нескольких методов. Сначала
вычисляется градиент изображения, на котором лучше видны резкие перепады
яркости. С его помощью на этом изображении обнаружаются контуры объектов. Среди
найденных контуров выделяются только те, которые являются прямыми линиями.
Далее из них выбирается четыре линии, с наибольшей вероятностью являющиеся
контурами пластины с номером. После этого, с помощью этих четырех линий,
находятся углы пластины с номером и вычисляется, каким образом нужно
преобразовать изображение, что бы исправить искажения перспективы.
.sp 1.0v
.PSPIC perspin.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 15. Пример пластины с номером, обнаруженной на фотографии. Зелеными точками
обозначены углы номерной пластины.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PSPIC perspout.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 16. Пластина с номером после исправления искажений перспективы. В таком
виде номер пригоден для дальнейшего распознавания.
.ce 0
.ps +2
.vs +2
.
.H2 "Градиент изображения. Оператор Собеля"
.PP
Градиент изображения \*- это набор векторов, в котором каждый элемент (вектор)
соответствует своему пикселю изображения. Направление вектора указывает из
соответствующего ему пикселя в ту сторону, двигаясь в которую, значения
пикселей будут возрастать быстрее всего, а модуль его показывает скорость
возрастания этих значений.
.PP
Если рассматривать непрерывную функцию, ее градиент является суммой
произведений производных по $x$, $y$ и векторов $i = (1,0)$, j = $(0,1)$ (такие
вектора называются базисными), соответственно:
.sp 0.5v
.EQ
{grad sub f} = {delta f} over {delta x} i+ {delta f} over {delta y} j
~ ,
.EN
.sp 0.5v
где $f$ \*- непрерывная функция, для которой ищется градиент, а $grad sub f$
\*- искомый градиент функции $f$.
.PP
Так как изображение, по сути, является дискретной функцией, т.е. функцией,
изменяющейся скачками, вычисление вектора градиента в каждой точке требует
прохода по всему изображению. Поэтому, градиент изоображения обычно вычисляется
приближенно. Для этого используется \*IОператор Собеля\*P, представляющий из
себя две матрицы $3 times 3$, использующихся для нахождения приближенных
производных по $x$ и по $y$ по отдельности.
.PP
Данные матрицы выглядят следующим образом:
.sp 0.5v
.EQ
{S sub x} =
left [
matrix {
ccol {-1 above  0 above 1}
ccol {-2 above 0 above 2}
ccol {-1 above  0 above 1}
}
right ]
~, ~~~
{S sub y} =
left [
matrix {
ccol {-1 above  -2 above -1}
ccol {0 above 0 above 0}
ccol {1 above  2 above 1}
}
right ]
~ .
.EN
.sp 0.5v
.PP
Для приближенного вычисления проризводных используется операция свёртки:
.sp 0.5v
.EQ
{G sub x} = S sub x * I = sum from {i = 1} to 3
sum from {j = 1} to 3 I [x - i, y - j] ~ S sub x [i, j]
.EN
.sp 0.5v
.EQ
{G sub y} = S sub y * I = sum from {i = 1} to 3
sum from {j = 1} to 3 I [x - i, y - j] ~ S sub y [i, j]
~, 
.EN
.sp 0.5v
где $I[x, y]$ \*- пиксель с координатами [x, y], а $S sub y [i, j]$ и
$S sub x [i, j]$ \*- элемент матрицы $S sub x$ или $S sub y$, соответственно,
находящийся в $i$-й столбце и $j$-й колонке. После этого, с помощью найденных
производных по $x$ и $y$ находятся направление и модуль градиента:
.sp 0.5v
.EQ
G = ( {{G sub x} sup 2 + {G sub y} sup 2} ) sup {^ size -2 {1 over 2}}
.EN
.sp 0.5v
.EQ
theta = roman "arctan" size -2 {{G sub y} over {G sub x}}
~ ,
.EN
.sp 0.5v
где $G$ \*- модуль градиента в точке, $theta$ \*- направление градиента в
точке\[one], а $G sub x$ и $G sub y$ \*- значения частных производных по $x$ и
$y$ в этой точке.
.
.FS \[one]
Важно учитывать, что если и $G sub x$, и $G sub y$ в точке отрицательны, то
минусы "уничтожают" друг друга. Этот случай следует обрабатывать отдельно, так
как иначе будет получено неверное значение.
.FE
.
.
.H2 "Детектор границ Канни"
.PP
Обнаружениие границ выполняется с помощью \*Iдетектора границ Канни\*P.
Детектор границ Канни является алгоритмом \*Iбинаризации\*P, т.е. он разделяет
пиксели на две группы: в первой группе находятся пиксели контура, а во второй
\*- все остальные.
.PP
Данный алгоритм использует вычисленный с помощью оператора Собеля или любым
другим способом градиент и состоит из нескольких этапов. Сначала выполняется
\*Iподавлениие немаксимумов\*P среди значений модуля градиента, потом
выполняется \*Iдвойная пороговая фильтрация\*P. После этого обрабатываются
пиксели, принадлежность контуру которых не была опредена на предыдущем этапе.
.PP
Результат возвращается в виде изображения (маски), где каждый пиксель
соответствует пикселю исходного изображения с такими же координатами. Пиксели
маски принимают одно из двух значений: 0 \*- если соответствующая точка
исходного изображения не принадлежит границе, и любого другое значение, если
принадлежит.
.PP
Подавление немаксимумов требуется для того, чтобы выделенная граница была
мининальной толщины, иначе говоря, чтобы она была четкой настолько, наколько
это возможно. Для этого выполняется проход по всем точкам градиента. Если
значение градиента в точке меньше, чем значение градиента в двух соседних
точках, находящихся слева и справа от вектора направления градиента, то ему
присваивается значение $0$.
.PP
Для упрощения реализации угол направления градиента дискретизируется,
т.е., вместо вещественных чисел представляется фиксированным количеством
значений. На основе дискретизированного значения угла уже определяется, с
какими соседними значениями градиента сравнивать значение градиента в текущей
точке. Ниже приведен полный алгоритм подавления немаксимумов:
.sp 0.5v
.RS
.PI
$G ^ [x, y]$ \*- значение градиента в точке с координатами [x, y].
.PI
$theta ^ [x, y]$ \*- угол градиента с осью $X$ в точке с координатами [x, y].
.PI
$w$ \*- ширина исходного изображения.
.PI
$h$ \*- высота исходного изображения.
.PI
$T$ \*- дискретизированное значение угла.
.PI
$L sub x$ \*- координата $x$ точки слева от вектора направления градиента.
.PI
$L sub y$ \*- координата $y$ точки слева от вектора направления градиента.
.PI
$R sub x$ \*- координата $x$ точки справа от вектора направления градиента.
.PI
$R sub y$ \*- координата $y$ точки справа от вектора направления градиента.
.RE
.sp 1.0v
.RS
Для всех $x$ от $1$ до $w$:
.RS
Для всех $y$ от $1$ до $h$:
.RS
.PI 1.
Дискретизировать\[one] угол направления градиента в точке $[x, y]$:
.
.FS \[one]
Здесь предполагается, что $theta ~ [ x, y ]$ лежит в интервале
$[ 0 ^ ; 2 pi ]$. Если это не так, пред этим его следует привести к этому
интервалу.
.FE
.
.sp 0.5v
.EQ
lpile {
T =  size -2 {{8 ^ left ( theta ^ [x, y] + size -2 {pi over 8} right )} over
{2 pi}} ~ roman "mod" ~ 8
= left [ size -2 {{4 theta ^ [x, y]} over pi} + size -2 {1 over 2} right ]
~ roman "mod" ~ 8
}
.EN
.sp 0.5v
.PI 2.
Определить, с какими из соседних точек следует сравнивать значение градиента:
.sp 0.5v
.EQ
lpile {
roman "если" ~ T = 0 ~ roman "или" ~ T = 4 ^ : ~ roman "тогда" ~
L sub x = x, ~~ L sub y = y + 1, ~~ R sub x = x, ~~ R sub y = y - 1
above
roman "если" ~ T = 2 ~ roman "или" ~ T = 6 ^ : ~ roman "тогда" ~
L sub x = x - 1, ~~ L sub y = y, ~~ R sub x = x + 1, ~~ R sub y = y
above
roman "если" ~ T = 1 ~ roman "или" ~ T = 5 ^ : ~ roman "тогда" ~
L sub x = x - 1, ~~ L sub y = y - 1, ~~ R sub x = x + 1, ~~ R sub y = y + 1
above
roman "если" ~ T = 3 ~ roman "или" ~ T = 7 ^ : ~ roman "тогда" ~
L sub x = x - 1, ~~ L sub y = y + 1, ~~ R sub x = x + 1, ~~ R sub y = y - 1
}
.EN
.sp 0.5v
.PI 3.
Сравнить значение градиента со значениями градиента в выбранных соседних
точках. Если оно меньше любого из них, заменить его значение нулем:
.sp 0.5v
.EQ
roman "если" ~ G ^ [ x, y ] < G ^ [ L sub x, L sub y ]
~ roman "или" ~ G ^ [ x, y ] < G ^ [ R sub x, R sub y ]
^ : ~ roman "тогда" ~ G ^ [x, y] = 0
.EN
.sp 0.5v
.RE
.RE
.RE
.sp 0.5v
.PP
После подавления немаксимумов выполняется двойная пороговая фильтрация.
Выбирается два значения, называемых порогами. Они задаются либо вручную, либо
определяются динамически, например, \*Iметодом Оцу\*P. Точки, в которых
значение градиента больше наибольшего из двух порогов, отмечаются как точки
границы. Те точки, значения которых лежат между двумя порогами, отмечаются как
неопределенные. Остальные точки отмечаются как фоновые:
.sp 0.5v
.RS
.PI
$G ^ [x, y]$ \*- значение градиента в точке с координатами [x, y].
.PI
$theta sub 1$ \*- наименьший из двух порогов
.PI
$theta sub 2$ \*- наибольший из двух порогов
.PI
$w$ \*- ширина исходного изображения.
.PI
$h$ \*- высота исходного изображения.
.PI
$m ^ [x, y]$ \*- точка $[x, y]$ выходной маски. Если ее значение равно $0$, то
точка $[x, y]$ изображения \*- фоновая, если $2$ \*- то это точка контура, если 
$1$ \*- ее принадлежность контуру пока не определена.
.RE
.sp 1.0v
.RS
Для всех $x$ от $1$ до $w$:
.RS
Для всех $y$ от $1$ до $h$:
.RS
.PI
Сравнить значение градиента в точке $[x, y]$ с порогами $theta sub 1$ и
$theta sub 2$:
.sp 0.5v
.EQ
lpile {
roman "если" ~ G ^ [x, y] < {theta sub 1} : ~ roman "тогда" ~ m ^ [ x, y ] = 0
above
roman "если" ~ G ^ [x, y] > {theta sub 2} : ~ roman "тогда" ~ m ^ [ x, y ] = 2
above
roman "если" ~ G ^ [x, y] > {theta sub 1} ~ roman "и"
~ G ^ [x, y] < {theta sub 2} : ~ roman "тогда" ~ m ^ [ x, y ] = 1
}
.EN
.sp 0.5v
.RE
.RE
.RE
.sp 0.5v
.PP
Далее обрабатываются точки, отмеченые как неопределенные. Это делается
следующим образом: если принадлежность точки контуру не была определена на
предыдущем этапе, но при этом хотябы одна из $8$ соседних для нее точек
принадлежит контуру, то она тоже помечается как точка контура:
.sp 0.5v
.RS
.PI
$G ^ [x, y]$ \*- значение градиента в точке с координатами [x, y].
.PI
$w$ \*- ширина исходного изображения.
.PI
$h$ \*- высота исходного изображения.
.PI
$m ^ [x, y]$ \*- точка $[x, y]$ выходной маски. Если ее значение равно $0$, то
точка $[x, y]$ изображения \*- фоновая, если $2$ \*- то это точка контура, если 
$1$ \*- ее принадлежность контуру пока не определена.
.RE
.sp 1.0v
.RS
Для всех $x$ от $1$ до $w$:
.RS
Для всех $y$ от $1$ до $h$:
.RS
.PI
Сравнить значение градиента в точке $[x, y]$ с порогами $theta sub 1$ и
$theta sub 2$:
.sp 0.5v
.EQ
lpile {
roman "если" ~ m ^ [x, y] = 1 :
above
~~~~ roman "если" ~ m ^ [x - 1, y - 1] = 2
~ roman "или если" ~ m ^ [x - 1, y] = 2
~ roman "или если" ~ m ^ [x - 1, y + 1] = 2
above
~~~~ roman "или если" ~ m ^ [x, y - 1] = 2
~ roman "или если" ~ m ^ [x, y] = 2
~ roman "или если" ~ m ^ [x, y + 1] = 2
above
~~~~ roman "или если" ~ m ^ [x + 1, y - 1] = 2
~ roman "или если" ~ m ^ [x + 1, y] = 2
above
~~~~ roman "или если" ~ m ^ [x + 1, y + 1] = 2 :
above
~~~~~~~~ roman "тогда" ~ m [x , y] = 2 ^ ,
above
~~~~ roman "иначе" ~ m ^ [x + 1, y + 1] = 0
}
.EN
.sp 0.5v
.RE
.RE
.RE
.
.sp 0.5v
.PSPIC cannyin.eps 12m
.PSPIC cannyout.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 17. Пример работы детектора границ Канни: сверху находится исходное
изображение, а снизу выходное изображение детектора.
.ce 0
.ps +2
.vs +2
.sp 0.5v
.
.H2 "Метод Оцу"
.PP
Как было сказано ранее, при использовании детектора границ Канни необходимо
задать два порога. Для нахождения верхнего порога в данной работе используется
\*IМетод Оцу\*P. Величина нижнего порога определяется как половина величины
верхнего.
.PP
Метод Оцу является алгоритмом бинаризации. Однако, в отличие от детектора 
границ Канни, он не выделяет границы, а просто подбирает порог, разделяющий
пиксели так, чтобы значения их яркостей внутри обоих групп были как можно ближе
друг к другу.
.PP
Один из способов выразить понятие "как можно ближе друг к другу" математическим
языком \*- это минимизация дисперсии. Т. е., чем ближе яркости пикселей друг к
другу, тем меньше дисперсия. Дисперсия внутри какой-либо группы величин (в
данном случае это яркости пикселей) называется \*Pвнутриклассовой
дисперсией\*I.
.PP
Для подбора порога, который разделит пиксели изображения так, чтобы дисперсия в
полученных группах была минимальна, можно использовать \*Iгистограмму\*P.
Гистограмма \*- это график, на котором каждому диапазону значений исследуемых
величин соответствует количество величин, попавших в этот диапазон. Говоря
математическим языком, гистограмма является дискретным вариантом функции
плотности распределения.
.
.sp 1.0v
.PSPIC hist.eps 24m
.ps -2
.vs -2
.ce 100
Рис. 18. Пример гистограммы. По горизонтальной оси расположены диапазоны
значений, а по вертикальной количество попаданий в соответствующий диапазон.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.
.PP
Далее, используя тот факт, что максимизация \*Iмежклассовой дисперсии\*P
эквивалентна минимизации внутриклассовой дисперсии, можно сильно сократить
количество необходимых вычислений. Под межклассовой дисперсией подразумевается
взвешенная дисперсия набора, состоящего из двух величин \*- средних
арифметических первой и второй группы. В роли весов выступают доли от общего
количества пикселей, входящие в первую и вторую группу соответственно:
.sp 0.5v
.EQ
pile {
w sub 0 + w sub 1 = 1
above
sigma = w sub 0 (a - E) sup 2 + w sub 1 (b - E) sup 2
= w sub 0 w sub 1 ( a - b ) sup 2
above
E = w sub 0 a + w sub 1 b
}
~ ,
.EN
.sp 0.5v
где $sigma$ \*- межклассовая дисперсия, $w0$ \*- доля количества пикселей
входящая в первую группу, $w1$ \*- доля количества пикселей входящая во вторую
группу, $a$ и $b$ \*- среднее арифметическое первой и второй групп
соответственно, а $E$ \*- общее математическое ожидание (среднее арифметическое
яркостей всех пикселей).
.PP
Для вычисления межклассовой дисперсии требуется знать только средние
арифметические групп и доли входящих в них пикселей. Можно использовать
гистограмму вместе двумя дополнительными величинами \*- суммой яркостей всех
пикселей и количеством пикселей. 
.PP
После того, как эти величины вычислены, выполняется проход по всем значениям
гистограммы. На каждом шаге прохода с помощью вспомогательных сумм и
дополнительных величин вычисляется межклассовая дисперсия. Если на каком-либо
шаге эта дисперсия больше максимальной из найденных (которая изначально равна
$-1$), то максимальной становится она, а как искомый порог (который изначально
равен $0$) задается положение текущего значения в гистограмме. Полученный после
полного прохода порог и будет разделять группы так, чтобы их внутренняя
дисперсия была максимальной.
.PP
В качестве вспомогательных сумм используются сумма яркостей пикселей и
количество пикселей в первой группе. Изначально они равны нулю. На каждом шаге
к первой сумме добавляется текущее значение гистограммы, домноженное на его
номер, а ко второй сумме просто текущее значение гистограммы. А так как группы
разделяются непосредственно в этом текущем значении гистограммы, то для
вычисления межклассовой дисперсии достаточно знать только эти вспомогательные
величины, общее количество пикселей, а также сумму яркостей всех пикселей.
.PP
Стоит заметить, что гистограмма строится для значений от $0$ до максимального
значения яркости пикселя (все возможные значения). Также, важно, что количество
значений в гистограмме, т.е. на сколько диапазонов разбиваются все возможные
значения, задается заранее. Поэтому, после нахождения необходимого порога, его
необходимо преобразовать, учитывая эти изменения, так, чтобы он соотвествовал
яркостям пикселей изображения, а не значениям гистограммы.
Ниже приведен полный алгоритм:
.sp 0.5v
.RS
.PI
$v sub max$ \*- максимальное значение яркости среди всех пикселей.
.PI
$h ^ [i]$ \*- $i$-е значение из гистограммы.
.PI
$I ^ [i, j]$ \*- значение яркости пикселя с координатами $[i, j]$.
.PI
$W$ \*- ширина изображения.
.PI
$H$ \*- высота изображения.
.PI
$N sub h$ \*- число значений в гистограмме.
.PI
$N$ \*- общее количество пикселей.
.PI
$V$ \*- сумма яркостей всех пикселей.
.PI
$sigma sub max$ \*- максимальная найденная на данный момент межклассовая
дисперсия.
.PI
$T$ \*- порог, соответствующий максимальной найденной на данный момент
межклассовой дисперсии.
.PI
$v$ и $n$ \*- вспомогательные суммы.
.PI
$w sub 0$ и $w sub 1$ \*- доли общего количества пикселей, входящие в первую и
вторую группы соответственно.
.PI
$a$ \*- среднее арифметическое пикселей, чьи яркости ниже текущего порога
(первая группа).
.PI
$sigma$ \*- текущая межклассвоая дисперсия.
.RE
.sp 1.0v
.RS
.PI 1.
Найти максимальное значение яркости пикселя:
.sp 0.5v
.EQ
v sub max = max I ^ [i, j]
.EN
.sp 0.5v
.PI 2.
Для $i$ от $0$ до $H$:
.RS
.PI
Для $j$ от $0$ до $W$:
.RS
.PI
Увеличить на $1$ значение гистограммы, соответствующее текущему значению
яркости:
.sp 0.5v
.EQ
m = left [ size -2 {{N sub h I ^ [i , j]} over {V sub max}} right ]
.EN
.sp 0.5v
.EQ
h ^ [m] = h ^ [m] + 1
.EN
.sp 0.5v
.RE
.RE
.PI 3.
Найти общее количество пикселей:
.sp 0.5v
.EQ
N = W H
.EN
.sp 0.5v
.PI 4.
Найти сумму всех яркостей пикселей с помощью гистораммы:
.sp 0.5v
.EQ
sum from {i = 0} to {N sub h} {i ^ h ^ [i]}
.EN
.sp 0.5v
.PI 5.
Инициализировать вспомогательные суммы:
.sp 0.5v
.EQ
pile {
v = 0
above
n = 0
}
.EN
.sp 0.5v
.PI 6.
Для каждого t от $0$ до $N sub h - 1$:
.RS
.PI a.
Увеличить вспомогательные суммы:
.sp 0.5v
.EQ
lpile {
v = v + t ^ h ^ [t]
above
n = n + h ^ [t]
}
.EN
.sp 0.5v
.PI b.
Вычислить долю пикселей, входящих в первую группу:
.sp 0.5v
.EQ
w sub 0 = size -2 {n over N}
.EN
.sp 0.5v
.PI c.
С помощью вспомогательных сумм вычислить текущую межклассовую дисперсию:
.sp 0.5v
.EQ
pile {
a = size -2 {v over n} - size -2 {{ V - v } over {N - n}}
above
sigma = w sub 0 ^ ( 1 - w sub 0 ) ^ a sup 2
}
.EN
.sp 0.5v
.RE
.PI 7.
Масштабировать порог так, чтобы он соответствовал яркостям пикселей избражения:
.sp 0.5v
.EQ
T = size -2 {{T ^ V sub max} over {N sub h}}
.EN
.sp 0.5v
.RE

.
.H2 "Преобразование Хафа"
.PP
После того, как контуры были выделены детектором границ Канни, среди них ищутся
прямые линии. Для этого используется преобразование Хафа. Оно, как и детектор
границ Канни, состоит из нескольких этапов. Сначала выполняется поиск прямых.
Далее выполняется подавление немаксимумов. А после этого линии, оставшиеся
после предыщего этапа сортируются по количеству голосов, полученных на первом
этапе.
.PP
Для поиска прямых в используется \*Iаккумулирующий массив\*P. Каждый элемент
массива соотвествуют одной из всех возможных прямых. Он является целым числом,
позывающим сколько точек, принадлежащих границе, лежит на этой прямой.
.PP
Изначально всем элементам аккумулирующего массива присваивается значение $0$,
далее выполняется проход по всем точкам, принадлежащим контуру. Для каждой
такой точки определяются все прямые, которые могут через нее проходить и
значения элементов аккумулирующего массива, соответствующие этим прямым,
увеличиваются на $1$.
.PP
Для поиска всех прямых, на которых может лежать точка (а также для определения
количества элементов аккумулирующего массива) используется уравнение прямой,
записанное в специальной форме:
.sp 0.5v
.EQ
r = x cos theta + y sin theta
~ ,
.EN
.sp 0.5v
где $theta$ \*- угол нормали прямой с осью $X$, а $r$ \*- минимальное
расстояние от точки $[0, 0]$ до прямой.
.sp 0.5v
.
.PSPIC houghline.eps 15m
.ps -2
.vs -2
.ce 100
Рис. 19. Представление прямой через угол нормали с осью $X$ и длину
перпендиикуляра.
.ce 0
.ps +2
.vs +2
.sp 0.5v
.PP
Так как параметры $theta$ и $r$ \*- вещественные числа, возможных прямых
бесконечное множество. Следовательно, полный их перебор невозможен. Поэтому
$theta$ и $r$ дискретизируются с заранее заданным шагом. Т.е. расстояние между
двумя соседними значениями параметра в дискретизированным виде равно
фиксированному значению. В данной работе параметр $theta$ дискретизируется с
шагом  $size -2 {pi over 180}$ (вместо радиан используются
целые углы), а параметр $r$ с шагом $1$ (просто округляется до ближайщего
целого).
.PP
Все прямые, проходящие через точку находятся с помощью приведенного выше
уравнения прямой. Выполняется проход для всех возможных значений $theta$, на
каждом шаге текущее значения $theta$ и координат точки подставляются в
уравнение прямой, и вычисляется значение параметра $r$. Так как при
фиксированном значении параметра $theta$, через конкретную точку может
проходить только одна прямая, таким образом можно найти все искомые прямые.
.PP
Для того чтобы быстро определять, какой элемент аккумулирующего массива
соответствует найденной прямой, аккумулирующий массив следует представить в
виде изображения. Для этого надо расположить его элементы в несколько строк
так, чтобы все элементы одной строки соответствовали прямым с одинаковым
значением $r$ (равным \*Iномеру\*P строки) и разными значениями
$theta$ (равными \*Iномеру\*P элемента в строке). Такое представление иногда
называют пространством Хафа. Теперь, для того, чтобы определить, какой элемент
аккумулирующего массива соответствует прямой со значениями параметров $theta$ и
$r$, достаточно найти точку в пространстве Хафа с координатами $[ theta , r ]$.
.PP
Важно отметить, что при представлении изображения в компьютере значения
координат точки (пикселя) обычно являются положительными целыми числами, а
значения параметров прямой не обязательно являются целыми и могут быть
отрицательными. Эта проблема решается в помощью смещения и маштабирования, т.е.
прямой со значениями параметров $theta$ и $r$ соотвествует элемент
аккумуллирующего массива с координатами
$[ a sub theta theta + b sub theta , a sub r r + b sub r ]$, где 
$a sub theta$ и $a sub r$ \*- маштабирующие коэффициенты параметров прямой,
а $b sub theta$ и $b sub r$ \*- их смещения.
.PP
Ниже приведен полный алгоритм нахождения прямых:
.sp 0.5v
.RS
.PI
$A ^ [a, d]$ \*- элемент аккумулирующего массива с координатами $[ a , d ]$.
.PI
$w$ \*- ширина входного изображения.
.PI
$h$ \*- высота входного изображения.
.PI
$T$ \*- ширина аккумулирующего массива.
.PI
$R$ \*- высота аккумулирующего массива.
.PI
$d theta$ \*- шаг дискретизации параметра $theta$.
.PI
$d r$ \*- шаг дискретизации параметра $r$.
.PI
$theta$ \*- значение параметра $theta$ текущей прямой.
.PI
$r$ \*- значение параметра $r$ текущей прямой.
.RE
.sp 1.0v
.RS
Для всех $x$ от $1$ до $w$:
.RS
Для всех $y$ от $1$ до $h$:
.RS
Если значение пикселя входного изображения с координатами $[ x , y ]$ не равно
$0$:
.RS
Для всех $a$ от нуля до T:
.RS
.PI 1.
Вычислить значение $theta$ для текущей прямой:
.sp 0.5v
.EQ
theta = a cdot d theta
.EN
.sp 0.5v
.PI 2.
Вычислить значение $r$ для текущей прямой:
.sp 0.5v
.EQ
r = x cos theta + y sin theta
.EN
.sp 0.5v
.PI 3.
Увеличить значение элемента аккумулирующего массива, соответствующего текущей
прямой:
.sp 0.5v
.EQ
A ^ [a, d + size -2 {R over 2}] = A ^ [a, d + size -2 {R over 2}] + 1
.EN
.sp 0.5v
.RE
.RE
.RE
.RE
.RE
.sp 0.5v
.PP
После заполнения аккумулирующего массива из него следует выбрать элементы,
являющееся максимумами и посторить из них список. При этом используется метод,
очень похожий на подавление немаксимумов в детекторе границ Канни. Только
сравнениие выполняется с четырьмя соседними элементами вместо двух:
.sp 0.5v
.RS
.PI
$A ^ [a, d]$ \*- элемент аккумулирующего массива с координатами $[ a , d ]$.
.PI
$T$ \*- ширина аккумулирующего массива.
.PI
$R$ \*- высота аккумулирующего массива.
.PI
${l sub theta} ^ [i]$ \*- параметр $theta$ $i$-й прямой в заполняемом списке.
.PI
${l sub r} ^ [i]$ \*- параметр $r$ $i$-й прямой в заполняемом списке.
.PI
${l sub v} ^ [i]$ \*- количество голосов, отданных за $i$-ю прямую в
заполняемом списке.
.PI
$L$ \*- количество прямых в заполняемом списке. Изначально равно нулю.
.PI
$d theta$ \*- шаг дискретизации параметра $theta$.
.PI
$d r$ \*- шаг дискретизации параметра $r$.
.RE
.sp 1.0v
.RS
Для всех $a$ от $1$ до $T$:
.RS
Для всех $d$ от $1$ до $R$:
.RS
Если значение элемента аккумулирующего массива с координатами $[a, d]$ не равно
нулю:
.RS
.PI
Если значение элемента аккумулирующего массива с координатами $[a, d]$
больше всех четырех соседних элементов, добавить значение параметров $theta$ и
$r$ прямой, которой он соответствует, в список:
.sp 0.5v
.EQ
lpile {
roman "если" ~ A ^ [a, d] > A ^ [a, d - 1] 
~ roman "и" ~ A ^ [a, d] > A ^ [a, d + 1]
above
~~~~ roman "и" ~ A ^ [a, d] > A ^ [a - 1, d]
~ roman "и" ~ A ^ [a, d] > A ^ [a + 1, d] ^ :
above
~~~~~~~~ roman "тогда" ~ l sub theta ^ [L] = a cdot d theta ,
~ l sub r ^ [L] = d - size -2 {R over 2}, ~ l sub v ^ [L] = A ^ [a, d] ,
~ L = L + 1
}
.EN
.RE
.RE
.RE
.RE
.sp 0.5v
.PP
После этого прямые в полученном списке сортируются по убыванию количества
голосов любым способом, например, \*Iбыстрой сортировкой\*P. На выход
подается отсортированный список, содержащий значения параметров $theta$ и $r$
найденых прямых.
.
.H2 "Поиск границ пластины" "с автомобильным номером"
.PP
Данный раздел раздел посвящен тому, каким образом комбинируются описанные
выше методы для того, чтобы находить границы номера.
.PP
Основой поиска границ пластины с номером в данной работе является выбор самых
ярких прямых, найденных преобразованием Хафа. Однако, границы пластины с
номером не всегда являются самыми яркими прямыми. 
.PP
Так как заранее примерно известно, в какой части изображения можно найти каждую
из четырех границ, то первое, что можно сделать, чтобы это исправить \*- это
разбить изображение на части и в каждой части искать отдельную границу.
.PP
Для поиска горизонтальных границ изображение разбивается горизонтальным
сечением на две части: верхнюю и нижнюю половины. В верхней половине ищется
верхняя граница номера, а в нижней \*- нижняя. Для поиска вертикальных границ
изображение разбивается вертикальным сечением на несколько равных частей (в
данной работе \*- на пять). В самой левой части ищется левая граница номера,
а в самой прямой \*- правая.
.sp 1.0v
.PSPIC num.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 20. Исходное изображение пластины с номером.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PSPIC numhorseg.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 21. Изображение пластины с номером, разбитое на верхнюю и нижнюю половины.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PSPIC numverseg.eps 12m
.ps -2
.vs -2
.ce 100
Рис. 22. Изображение пластины с номером, разбитое на пять частей вертикальным
сечением.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Для того, чтобы вертикальные границы пластины с номером (так как они менее
яркие, чем горизонтальные) лучше обнаруживались c помощью преобразования Хафа,
части изображения, в которых они ищутся, растягиваются по высоте (в данной
работе они растягиваются так, чтобы их высота была равна ширине всего
изображения с пластиной). Таким образом все вертикальные прямые на них при
преобразовании Хафа получат больше голосов.
.sp 1.0v
.PSPIC numversegstretched.eps 4m
.ps -2
.vs -2
.ce 100
Рис. 23. Растянутые изображения, в которых ищутся вертикальные границы.
.ce 0
.ps +2
.vs +2
.sp 1.0v
.PP
Также, можно использовать разные дополнительные условия, чтобы отсеять
некоторые яркие прямые (найденные с помощью преобразования Хафа), не являющиеся
границами пластины с номером. В данной работе использется два дополнительных
условия.
.PP
Первое из них заключается в проверке угла наклона прямых. Если ищется верхняя
или нижняя граница номера, то прямые, параметр $theta$ которых меньше
$size -2 {pi over 4}$ или больше $size -2 {{3 pi} over 4}$ (т.е. прямые, не
являющиеся горизонтальными) не рассматриваются. Аналогично, если ищется левая
или правая граница: не рассматриваются прямые, чей параметр $theta$ больше
$size -2 {pi over 4}$ и меньше $size -2 {{3 pi} over 4}$ (прямые, не являющиеся
вертикальными).
.PP
Второе дополнительное условие основанно на том факте, пластина с автомобильным
номером обычно белого цвета и имеет черные края. Поэтому второе условие
заключается в сравненнии сумм яркостей в двух полосах (область изображения,
ограниченная двумя прямыми). Первая полоса, лежит непосредственно на
обнаруженной прямой. Вторая полоса лежит вплотную к первой по ту сторому от
нее, по которую должна находиться пластина с номером. Если сумма яркостей
пикселей, находящихся в первой полосе меньше, чем такая же сумма во второй
полосе, то обнаруженная прямая считается границей пластины с номером, иначе
прямая больше не рассматривается.
.PP
Второе условие применяется только при поиске вертикальных границ пластины с
номером (горизонтальные прямые, для которых выполняется первое условие, сразу
считаются границами пластины с номером), так как на практике результат этой
проверки для горизонтальных границ был неудовлетворительным. Это следствие
того, что горизонтальные границы пластины итак обычно являются самыми яркими,
и, следовательно добавление этой проверки при их поиске несет лишь
дополнительные ошибки распознавания.
.PP
Ширина полосы выбирается как доля от ширины или высоты. Т.е. ширина
горизонтальных полос равняется высоте изображения, умноженной на заранее
определенную константу (которая больше нуля и меньше единицы), а ширина
вертикальных полос \*- равняется ширине изображения, умноженной на другую
заранее определенную константу (которая также больше нуля и меньше единицы).
.PP
Каждая полоса представляется в виде двух прямых (границ полосы), чьи параметры
$theta$ равны, а параметры $r$ отличаются на ширину полосы (т.е. модуль их
разности равен ширине полосы). Для того, чтобы проверить, лежит ли точка в
полосе, ищется прямая, проходящая через эту точку, с таким же параметром
$theta$, как и границы полосы. Если значение параметра $r$ этой прямой лежит
между значениями параметров $r$ границ полосы, то точка лежит в полосе.
.PP
Нахождение параметра $r$ такой прямой, по сути, является нахождением проекции
точки $[x, y]$ на перпендикуляр к границам полосы. Эту проекцию можно найти как
длину катета, прилежащего к углу между прямой, проведенной из точки $[0, 0]$ в
точку $[x, y]$ и перпендикуляром к границам полосы.
.PP
Алгоритм суммирования яркостей всех пикселей, лежащих в полосе выглядит так:
.sp 1.0v
.RS
.PI
$I ^ [x, y]$ \*- пиксель изображения (содержащего яркости), на котором ищется
прямая.
.PI
$w$ \*- ширина изображения, на котором ищется прямая.
.PI
$h$ \*- высота изображения, на котором ищется прямая.
.PI
$theta$ \*- параметр $theta$ обоих прямых, составляющих полосу.
.PI
$r sub 0$, $r sub 1$ \*- параметр $r$ первой и второй прямых составляющих
полосу. $r sub 0$ должен быть меньше, чем $r sub 1$.
.PI
$phi$ \*- угол прямой, проведенной из точки $[0, 0]$ в точку $[x, y]$ с осью
$X$.
.PI
$d$ \*- длина прямой, проведенной из точки $[0, 0]$ в точку $[x, y]$. 
.PI
$rho$ \*- проекция точки $[x, y]$ на перпендикуляр к границам полосы.
.PI
$S$ \*- сумма пикселей в полосе. Изначально равна нулю.
.RE
.sp 1.0v
.RS
Для всех $a$ от $1$ до $w$:
.RS
Для всех $d$ от $1$ до $h$:
.RS
.PI 1.
Вычислить длину и угол с осью $X$ прямой, проходящей из точки $[0, 0]$ в точку
$[x, y]$:
.sp 0.5v
.EQ
phi = roman "arctan" size -2 {y over x}
.EN
.sp 0.5v
.EQ
d = sqrt{x sup 2 + y sup 2}
.EN
.sp 0.5v
.PI 2.
Вычислить значение проекции точки $[x, y]$ на перпендикуляр к границам полосы:
.sp 0.5v
.EQ
rho = d cos ({phi - theta})
.EN
.sp 0.5v
.PI 3.
Если проекция точки $[x, y]$ лежит между параметрами $r$ границ полосы, то
она лежит в полосе и, следовательно, значение яркости пикселя с этими
координатами надо прибавить к сумме:
.sp 0.5v
.EQ
roman "если" ~ rho > r sub 0 ~ roman "и" ~ rho < r sub 1 :
~ roman "тогда" ~ s = s + I ^ [x, y]
.EN
.sp 0.5v
.RE
.RE
.RE
.PP
После того, как граница пластины с номером была найдена, она переводится из
представления через перпендикуляр и его угол с осью $X$ в представление через
две точки, лежащие на ней:
.sp 0.5v
.EQ
lpile {
roman "если" ~ theta > epsilon ~ : ~ 
above
roman "иначе" ~
}
lpile {
p sub 0x = 0, ~~ p sub 0y = size -2 {r over {sin theta}}, ~~
p sub 1x = w, ~~ p sub 1y = r - w size -2 {{cos theta} over {sin theta}} ,
above
p sub 0x = r , ~~ p sub 0y = 0, ~~
p sub 1x = r , ~~ p sub 1y = h
}
~ ,
.EN
.sp 0.5v
где $theta$ и $r$ \*- параметры прямой в представлении через перпендикуляр и
его угол с осью $X$, $w$ и $h$ \*- ширина и высота изображения с пластиной,
$p sub 0x$ и $p sub 0y$ \*- координаты первой точки в новом представлении
линии, а $p sub 1x$ и $p sub 1y$ \*- координаты второй точки в новом
представлении линии.
.PP
После того, как были найдены все четыре границы пластины, составляющие контур
номера, ищутся координаты её углов. Для этого находятся точки пересечения левой
и верхней (левый верхний угол пластины), левой и нижней (левый нижний угол
пластины), правой и верхней (правый верхний угол пластины), правой и нижней
(правый нижний угол пластины) границ.
.PP
Далее, c помощью найденных координат углов выполняется перспективное
преобразование изображения с пластиной, и после этого выполняется распознавание
отдельных символов на пластине.
.
.H2 "Перспективные преобразования"
.PP
Как уже говорилось, после того, как все четыре угла пластины с номером найдены,
выполняется перспективное преобразование, изменяющее избражение пластины с
номером так, чтобы найденные углы совпадали с углами выбранного заранее
четырёхугольника (Рис. 15, Рис. 16). Иначе говоря, пластина на изображении
должна быть расположена таким образом, будто съемка выполнялась под прямым
углом без каких-либо поворотов.
.PP
Такое преобразование можно получить с помощью линейной алгебры. В этом случае,
оно будет представлено в виде матрицы. Умножение координат пикселя итогового
изображения на эту матрицу даст координаты соответствующей им точки на
оригинальном изображении. Далее с помощью этой матрицы можно выполнить проход
по всем пикселям итогового изображения, на каждом шаге находя соответствующую
текущему пикселю точку оригинального изображения и выполняя билинейную
интерполяцию.
.PP
Как можно заметить, используется способ, похожий на тот, который использовался
при масштабировании. Отличие заключается только в том, что для нахождения
соответствующей точки оригинального изображения вместо деления используется
матрица. На самом деле построить матрицу можно и для масштабирования. Однако
это не будет соответствовать сложности задачи, поэтому был выбран более простой
метод, использующий деление.
.PP
Матрица для перспективного преобразования состоит из двух других матриц,
"комбинируемых" с помощью матричного умножения. Первая матрица преобразует
координаты пикселя итогового изображения в промежуточные точки, а вторая
преобразует полученные промежуточные точки в искомые координаты на оригинальном
изображении.
.PP
Обе матрицы будут искаться в виде квадратных матриц $3 times 3$. Поэтому,
чтобы выполнять с их помощью преобразования, координаты будут представляться в
виде вектора из трех компонент. Первые две компоненты вектора \*- это $x$ и $y$
координаты, а третья равняется единице.
.PP
Сначала ищется вторая матрица, преобразующая промежуточные точки в
координаты на оригинальном изображении. Для этого достаточно, чтобы она
преобразовывала четыре промежуточные точки в координаты углов выделенного на
оригинальном изображении четырёхугольника. В качесте этих точек используются
точки $(1, 0, 0)$, $(0, 1, 0)$, $(0, 0, 1)$ и $(1, 1, 1)$.
.PP
Матрица для отображения первых трех промежуточных точек в первые три угла будет
выглядеть следующим образом:
.sp 0.5v
.EQ
left [
matrix {
ccol { x sub 1 above y sub 1 above 1 }
ccol { x sub 2 above y sub 2 above 1 }
ccol { x sub 3 above y sub 3 above 1 }
}
right ]
~~ ,
.EN
.sp 0.5v
где $x sub 1$, $x sub 2$, $x sub 3$, $y sub 1$, $y sub 2$ и $y sub 3$ \*-
$x$-координаты и $y$-координаты углов четырёхугольника на оригинальном
изображении. 
.PP
Чтобы четвертая промежуточная также преобразовывалась в координаты четвертого
угла, столбцы матрицы умножаются на такие подбираемые значения, чтобы
выполнялось равенство:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a x sub 1} above {b y sub 1} above c }
ccol { {a x sub 2} above {b y sub 1} above c }
ccol { {a x sub 3} above {b y sub 1} above c }
}
right ]
times
left [
matrix {
ccol { 1 above 1 above 1 }
}
right ]
=
left [
matrix {
ccol { x sub 4 above y sub 4 above 1 }
}
right ]
~~ ,
.EN
.sp 0.5v
где $x sub 1$, $x sub 2$, $x sub 3$, $x sub 4$, $y sub 1$, $y sub 2$, $y sub 4$
и $y sub 4$ \*- $x$-координаты и $y$-координаты углов четырёхугольника на
оригинальном изображении, а $a$, $b$ и $c$ \*- подбираемые значения. Это
равенство можно записать другим образом:
.sp 0.5v
.EQ
left [
matrix {
ccol { {x sub 1} above {y sub 1} above 1 }
ccol { {x sub 2} above {y sub 1} above 1 }
ccol { {x sub 3} above {y sub 1} above 1 }
}
right ]
times
left [
matrix {
ccol { a above b above c }
}
right ]
=
left [
matrix {
ccol { x sub 4 above y sub 4 above 1 }
}
right ]
~~ ,
.EN
.sp 0.5v
.PP
Такое равенство, по сути, является системой линейных уравнений, где в роли
неизвестных выступают значения $a$, $b$ и $c$. Такую систему можно решить с
помощью одного из численных методов, например, \*Iметодом Гаусса-Жордана\*P,
который будет описан в следующием разделе.
.PP
В итоге будет получена матрица $A$:
.sp 0.5v
.EQ
A
= 
left [
matrix {
ccol { {a x sub 1} above {b y sub 1} above c }
ccol { {a x sub 2} above {b y sub 1} above c }
ccol { {a x sub 3} above {b y sub 1} above c }
}
right ]
~~ ,
.EN
.sp 0.5v
которая преобразует $(1, 0, 0)$ в $( a x sub 1, a y sub 1, a )$,
$(0, 1, 0)$ в $( b x sub 2, b y sub 2, b )$,
$(0, 0, 1)$ в $( c x sub 3, c y sub 3, c )$, а
$(1, 1, 1)$ в $( x sub 4, y sub 4, 1 )$. При преобразовании первых трех
координат появляются лишние множители, однако их можно убрать, если после
умножения каждую компоненту результата делить на его $z$-компоненту.
.PP
Описанный выше способ также используется при получении первой матрицы,
преобразующей координаты пикселя в итоговом изображении в промежуточные точки.
Сначала с помощью него строится матрица $B$, преобразующая промежуточные точки
$(1, 0, 0)$, $(0, 1, 0)$, $(0, 0, 1)$ и $(1, 1, 1)$ в координаты углов
четырёхугольника, выделенного на итоговом изображении. После этого с помощью
метода Гаусса-Жордана находится матрица $B sup {^ -1}$, обратная к полученной.
Как и в случае со второй матрицей, после умножения на матрицу $B sup {^ -1}$
каждую компоненту результата нужно разделить на его $z$-компоненту.
.PP
Итоговая матрица $C$, используемая для преобразования координат пикселя
итогового изображения в координаты соответствующей ему точки на оригинальном
изображении, будет результатом умножения матрицы $A$ на матрицу $B sup {^ -1}$:
.sp 0.5v
.EQ
C = A times B sup {^ -1}
~~ .
.EN
.sp 0.5v
.PP
Преобразование выполняется с помощью умножения координат пикселя итогового
изображения на матрицу $C$. После этого необходимо разделить все компоненты
полученного в итоге вектора на его z-компоненту, чтобы убрать лишние множители,
которые добавляются матрицами составляющих $C$.
.PP
Ниже приведен полный алгоритм получения матрицы для перспективного
преобразования:
.sp 1.0v
.RS
.PI
$x sub 1$, $x sub 2$, $x sub 3$, $x sub 4$, $y sub 1$, $y sub 2$, $y sub 3$ и
$y sub 4$ \*- $x$-координаты и $y$-координаты углов четырёхугольника,
выделенного на оригинальном изображении.
.PI
${x tilde} sub 1$, ${x tilde} sub 2$, ${x tilde} sub 3$, ${x tilde} sub 4$,
${y tilde} sub 1$, ${y tilde} sub 2$, ${y tilde} sub 3$ и ${y tilde} sub 4$ \*-
$x$-координаты и $y$-координаты углов четырёхугольника, выделенного на итоговом
изображении.
.PI
$A$ \*- матрица, преобразующая промежуточные точки в координаты на оригинальном
изображении.
.PI
$B$ \*- матрица, преобразующая промежуточные точки в координаты на итоговом
изображении.
.PI
$B sup {^ -1}$ \*- матрица, преобразующая координаты пикселя итогового
изображения в промежуточные точки.
.PI
$C$ \*- итоговая матрица, преобразующая координаты пикселя итогового
изображения в соответствующие координаты на оригинальном изображении.
.PI
$a$, $b$ и $c$ \*- подбираемые значения для матрицы $A$.
.PI
$a tilde$, $b tilde$ и $c tilde$ \*- подбираемые значения для матрицы $B$.
.RE
.sp 1.0v
.RS
.PI 1.
Найти значения $a$, $b$ и $c$, решив систему линейных уравнений:
.sp 0.5v
.EQ
left [
matrix {
ccol { {x sub 1} above {y sub 1} above 1 }
ccol { {x sub 2} above {y sub 1} above 1 }
ccol { {x sub 3} above {y sub 1} above 1 }
}
right ]
times
left [
matrix {
ccol { a above b above c }
}
right ]
=
left [
matrix {
ccol { x sub 4 above y sub 4 above 1 }
}
right ]
.EN
.sp 0.5v
.PI 2.
Построить матрицу $A$:
.sp 0.5v
.EQ
A
= 
left [
matrix {
ccol { {a x sub 1} above {b y sub 1} above c }
ccol { {a x sub 2} above {b y sub 1} above c }
ccol { {a x sub 3} above {b y sub 1} above c }
}
right ]
.EN
.sp 0.5v
.PI 3.
Найти значения $a tilde$, $b tilde$ и $c tilde$,
решив систему линейных уравнений:
.sp 0.5v
.EQ
left [
matrix {
ccol { {{x tilde} sub 1} above {{y tilde} sub 1} above 1 }
ccol { {{x tilde} sub 2} above {{y tilde} sub 1} above 1 }
ccol { {{x tilde} sub 3} above {{y tilde} sub 1} above 1 }
}
right ]
times
left [
matrix {
ccol { {a tilde} above {b tilde} above {c tilde} }
}
right ]
=
left [
matrix {
ccol { {{x tilde} sub 4} above {{y tilde} sub 4} above 1 }
}
right ]
.EN
.sp 0.5v
.PI 4.
Построить матрицу $B$:
.sp 0.5v
.EQ
B
= 
left [
matrix {
ccol { {{a tilde} {x tilde} sub 1}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
ccol { {{a tilde} {x tilde} sub 2}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
ccol { {{a tilde} {x tilde} sub 3}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
}
right ]
.EN
.sp 0.5v
.PI 5.
Найти матрицу, обратную для матрицы $B$:
.sp 0.5v
.EQ
B sup {^ -1}
= 
left [
matrix {
ccol { {{a tilde} {x tilde} sub 1}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
ccol { {{a tilde} {x tilde} sub 2}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
ccol { {{a tilde} {x tilde} sub 3}
above {{b tilde} {y tilde} sub 1}
above {c tilde} }
}
right ] sup {^ -1}
.EN
.sp 0.5v
.PI 6.
Построить матрицу $C$:
.sp 0.5v
.EQ
C = A times B sup {^ -1}
.EN
.sp 0.5v
.RE
.sp 1.0v
.
.H2 "Решение системы линейных уравнений" "методом Гаусса\*-Жордана"
.PP
Для нахождении коэффициентов в матрицах, составляющих матрицу перспективного
преобразования, требуется решить систему линейных уравнений. Это делается с
помощью метода Гаусса-Жордана, являющегося модификацией метода Гаусса.
.PP
Оба метода используют тот факт, что элементарные преобразования матрицы, не
меняют множества решений системы линейных уравнений, которую эта матрица
представляет. Под элементарными преобразованиями матрицы подразумеваются:
.sp 0.5v
.RS
.PI \(bu
Перестановка строк матрицы:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31} }
ccol { {a sub 12} above {a sub 22} above {a sub 32} }
ccol { {a sub 13} above {a sub 23} above {a sub 33} }
}
right ]
->
left [
matrix {
ccol { {a sub 21} above {a sub 11} above {a sub 31} }
ccol { {a sub 22} above {a sub 12} above {a sub 32} }
ccol { {a sub 23} above {a sub 13} above {a sub 33} }
}
right ]
.EN
.sp 0.5v
.PI \(bu
Умножение строки матрицы на ненулевую константу:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31} }
ccol { {a sub 12} above {a sub 22} above {a sub 32} }
ccol { {a sub 13} above {a sub 23} above {a sub 33} }
}
right ]
->
left [
matrix {
ccol { {a sub 11} above {beta a sub 21} above {a sub 31} }
ccol { {a sub 12} above {beta a sub 22} above {a sub 32} }
ccol { {a sub 13} above {beta a sub 23} above {a sub 33} }
}
right ]
.EN
.sp 0.5v
.PI \(bu
Прибавление одной строки матрицы, умноженной на константу, к другой:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31} }
ccol { {a sub 12} above {a sub 22} above {a sub 32} }
ccol { {a sub 13} above {a sub 23} above {a sub 33} }
}
right ]
->
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31 + beta a sub 11} }
ccol { {a sub 12} above {a sub 22} above {a sub 32 + beta a sub 12} }
ccol { {a sub 13} above {a sub 23} above {a sub 33 + beta a sub 13} }
}
right ]
.EN
.RE
.sp 0.5v
.PP
Метод Гаусса-Жордана используется для решения системы линейных уравнений,
представленной в следующем виде:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31} }
ccol { {a sub 12} above {a sub 22} above {a sub 32} }
ccol { {a sub 13} above {a sub 23} above {a sub 33} }
}
right ]
times
left [
matrix {
ccol { {x sub 1} above {x sub 2} above {x sub 3} }
}
right ]
=
left [
matrix {
ccol { {b sub 1} above {b sub 2} above {b sub 3} }
}
right ]
.EN
.sp 0.5v
Данную систему можно записать следующим образом:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11 x sub 1} above {a sub 21 x sub 1} above {a sub 31 x sub 1} }
ccol { {a sub 12 x sub 2} above {a sub 22 x sub 2} above {a sub 32 x sub 2} }
ccol { {a sub 13 x sub 3} above {a sub 23 x sub 3} above {a sub 33 x sub 3} }
}
left |
matrix {
ccol { {b sub 13} above {b sub 23} above {b sub 33} }
}
right ]
.EN
.sp 0.5v
.PP
Теперь можно прибавить первую строку к остальным строкам. При каждом сложении
умножая её на отрицание отношения первого элемента строки, к которой она
прибавляется, к её первому элементу. После этого, все значения в первом
столбце, кроме первого, станут равны нулю:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11 x sub 1} above {a sub 21 x sub 1} above {a sub 31 x sub 1} }
ccol { {a sub 12 x sub 2} above {a sub 22 x sub 2} above {a sub 32 x sub 2} }
ccol { {a sub 13 x sub 3} above {a sub 23 x sub 3} above {a sub 33 x sub 3} }
}
left |
matrix {
ccol { {b sub 1} above {b sub 2} above {b sub 3} }
}
right "" 
right ]
->
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { {a sub 12 x sub 2}
above {{a dot} sub 22 x sub 2}
above {{a dot} sub 32 x sub 2} }
ccol { {a sub 13 x sub 3}
above {{a dot} sub 23 x sub 3}
above {{a dot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {b sub 1} above {{b dot} sub 2} above {{b dot} sub 3} }
}
right "" 
right ]
~~ ,
.EN
.sp 0.5v
.EQ
lpile {
{a dot} sub 22 = a sub 22 - size -2 {a sub 21 over a sub 11} a sub 12
~ , ~~
{a dot} sub 23 = a sub 23 - size -2 {a sub 21 over a sub 11} a sub 13
~ , ~~
{b dot} sub 2 = b sub 2 - size -2 {a sub 21 over a sub 11} b sub 1
~ ,
above
{a dot} sub 32 = a sub 32 - size -2 {a sub 31 over a sub 11} a sub 12
~ , ~~
{a dot} sub 33 = a sub 33 - size -2 {a sub 31 over a sub 11} a sub 13
~ , ~~
{b dot} sub 3 = b sub 3 - size -2 {a sub 31 over a sub 11} b sub 1
~ ,
}
.EN
.sp 0.5v
.PP
Таким же образом, прибавляя вторую строку к остальным, умножая её на отношение
второго элемента строки, к которой она прибавляется к её второму элементу,
можно обнулить весь второй столбец за исключением одного элемента:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { {a sub 12 x sub 2}
above {{a dot} sub 22 x sub 2}
above {{a dot} sub 32 x sub 2} }
ccol { {a sub 13 x sub 3}
above {{a dot} sub 23 x sub 3}
above {{a dot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {b sub 1} above {{b dot} sub 2} above {{b dot} sub 3} }
}
right "" 
right ]
->
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22 x sub 2}
above 0 }
ccol { {{a dotdot} sub 13 x sub 3}
above {{a dot} sub 23 x sub 3}
above {{a dotdot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {{b dotdot} sub 1} above {{b dot} sub 2} above {{b dotdot} sub 3} }
}
right "" 
right ]
~~ ,
.EN
.sp 0.5v
.EQ
lpile {
{a dotdot} sub 13 = a sub 13
- size -2 {a sub 12 over {a dot} sub 22} {a dot} sub 23
~ , ~~
{b dotdot} sub 1 = b sub 1
- size -2 {a sub 12 over {a dot} sub 22} {b dot} sub 2
above
{a dotdot} sub 33 = {a dot} sub 33
- size -2 {{a dot} sub 32 over {a dot} sub 22} {a dot} sub 23
~ , ~~
{b dotdot} sub 3 = {b dot} sub 3
- size -2 {{a dot} sub 32 over {a dot} sub 22} {b dot} sub 2
}
.EN
.sp 0.5v.
.PP
Данные действия можно повторять для оставшихся строк, пока все значения в левой
части матрицы, кроме тех, что лежат на главной диагонали, не станут равны нулю.
В матрице, приведенной в примере, осталась только третья строка:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22 x sub 2}
above 0 }
ccol { {{a dotdot} sub 13 x sub 3}
above {{a dot} sub 23 x sub 3}
above {{a dotdot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {{b dotdot} sub 1} above {{b dot} sub 2} above {{b dotdot} sub 3} }
}
right "" 
right ]
->
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22 x sub 2}
above 0 }
ccol {0 
above 0
above {{a dotdot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {{b tilde} sub 1} above {{b tilde} sub 2} above {{b dotdot} sub 3} }
}
right "" 
right ]
~~ ,
.EN
.sp 0.5v
.EQ
lpile {
{b tilde} sub 1 = {b dotdot} sub 1
- size -2 {{a dotdot} sub 13 over {a dotdot} sub 33} {b dotdot} sub 3
~ , ~~
{b tilde} sub 2 = {b dot} sub 2
- size -2 {{a dot} sub 23 over {a dotdot} sub 33} {b dotdot} sub 3
}
.EN
.sp 0.5v.
.PP
После этого, если разделить каждую строку на оставшийся элемент, лежащий на
главной диагонали, то левая часть будет содержать только переменные, а правая
часть будет являться искомым решением.
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11 x sub 1}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22 x sub 2}
above 0 }
ccol {0 
above 0
above {{a dotdot} sub 33 x sub 3} }
}
left |
matrix {
ccol { {{b tilde} sub 1} above {{b tilde} sub 2} above {{b dotdot} sub 3} }
}
right "" 
right ]
->
left [
matrix {
ccol { {x sub 1}
above 0
above 0 }
ccol { 0
above {x sub 2}
above 0 }
ccol {0 
above 0
above {x sub 3} }
}
left |
matrix {
ccol { {{b hat} sub 1} above {{b hat} sub 2} above {{b hat} sub 3} }
}
right "" 
right ]
->
left {
lpile {
x sub 1 = {b hat} sub 1
above
x sub 2 = {b hat} sub 2
above
x sub 3 = {b hat} sub 3
}
right ""
~~ ,
.EN
.sp 0.5v
.EQ
lpile {
{b hat} sub 1 = size -2 {{b tilde} sub 1 over a sub 11}
~ , ~~
{b hat} sub 2 = size -2 {{b tilde} sub 2 over {a dotdot} sub 22}
~ , ~~
{b hat} sub 3 = size -2 {{b dotdot} sub 3 over {a dotdot} sub 33}
}
.EN
.sp 0.5v.
.PP
В общем виде алгоритм будет выглядеть следующим образом:
.sp 0.5v.
.RS
.PI
$a sub ij$ \*- коэффициент перед $x sub j$, стоящий на $j$-й позиции в $i$-й
строке.
.PI
$b sub i$ \*- элемент правой части, стоящий в $i$-й строке.
.RE
.sp 0.5v.
.RS
.PI 1.
Для каждого $i$ от $0$ до $n - 1$:
.RS
.PI
Для каждого $j$ от $0$ до $n - 1$:
.RS
.PI
Обнулить все элементы $i$-го столбца левой части, кроме того, что стоит на
главной диагонали:
.sp 0.5v
.EQ
a sub jk = a sub jk - size -2 {a sub ji over a sub ii} a sub ik
~ , ~~ k \(mo ^ [0 ; n - 1] ^ ; ~~
b sub j = b sub j - size -2 {a sub ji over a sub ii} b sub i
.EN
.sp 0.5v
.RE
.RE
.PI 2.
Для каждого $i$ от $0$ до $n - 1$:
.RS
.PI
Для каждого $j$ от $0$ до $n - 1$:
.sp 0.5v
.EQ
a sub ij = size -2 {a sub ij over a sub ii}
~~ , ~
b sub j = size -2 {b sub j over a sub ii}
.EN
.sp 0.5v
.RE
.RE
.PP
Важное замечание: перед тем как решать систему линейных уравнений методом
Гаусса-Жордана, необходимо убедиться, что на главной диагонали матрицы,
представляющей эту систему нет нулей. А если нули есть, то можно попробовать
переставить строки так, чтобы они не находились на главной диагонали. 
В случае, если этого сделать нельзя или матрица вообще не является квадратной,
единственного решения не существует.
.
.H2 "Нахождение обратной матрицы" "методом Гаусса\*-Жордана"
.PP
Метод Гаусса\*-Жордана также можно использовать для нахождения обратной
матрицы. Так как матрица, обратная к матрице $A$ \*- это матрица, которая при
перемножении с матрицей $A$ дает единичную матрицу, задачу о нахождении
обратной матрицы можно записать так:
.sp 0.5v
.EQ
left [
matrix {
ccol {{a sub 11} above {a sub 12} above {a sub 13}}
ccol {{a sub 21} above {a sub 22} above {a sub 23}}
ccol {{a sub 31} above {a sub 32} above {a sub 33}}
}
right ]
times
left [
matrix {
ccol {{b sub 11} above {b sub 12} above {b sub 13}}
ccol {{b sub 21} above {b sub 22} above {b sub 23}}
ccol {{b sub 31} above {b sub 32} above {b sub 33}}
}
right ]
=
left [
matrix {
ccol {1 above 0 above 0}
ccol {0 above 1 above 0}
ccol {0 above 0 above 1}
}
right ]
.EN
.sp 0.5v
.PP
Каждый столбец результата умножения матрицы $A$ на матрицу $B$,
является результатом умножения матрицы $A$ на соответствующий столбец матрицы
$B$. Следовательно, нахождение каждого столбца обратной матрицы можно
сформулировать как отдельную задачу:
.sp 0.5v
.EQ
left [
matrix {
ccol {{a sub 11} above {a sub 12} above {a sub 13}}
ccol {{a sub 21} above {a sub 22} above {a sub 23}}
ccol {{a sub 31} above {a sub 32} above {a sub 33}}
}
right ]
times
left [
matrix {
ccol {{b sub 11} above {b sub 12} above {b sub 13}}
}
right ]
=
left [
matrix {
ccol {1 above 0 above 0}
}
right ]
~ ; ~~
left [
matrix {
ccol {{a sub 11} above {a sub 12} above {a sub 13}}
ccol {{a sub 21} above {a sub 22} above {a sub 23}}
ccol {{a sub 31} above {a sub 32} above {a sub 33}}
}
right ]
times
left [
matrix {
ccol {{b sub 21} above {b sub 22} above {b sub 23}}
}
right ]
=
left [
matrix {
ccol {0 above 0 above 1}
}
right ]
~ ;
.EN
.sp 0.5v
.EQ
left [
matrix {
ccol {{a sub 11} above {a sub 12} above {a sub 13}}
ccol {{a sub 21} above {a sub 22} above {a sub 23}}
ccol {{a sub 31} above {a sub 32} above {a sub 33}}
}
right ]
times
left [
matrix {
ccol {{b sub 31} above {b sub 32} above {b sub 33}}
}
right ]
=
left [
matrix {
ccol {0 above 1 above 0}
}
right ]
~ .
.EN
.sp 0.5v
.PP
Теперь видно, что для нахождения каждого столбца обратной матрицы необходимо
решить систему линейных уравнений. Причем, для всех столбцов коэффициенты перед
неизвестными одинаковые. А так как при решении системы линейных уравнений
методом Гаусса\*-Жордана в левой части изменяются только эти коэффициенты,
достаточно выполнить все необходимые преобразования один раз, дублируя их для
каждой правой части.
.PP
Таким образом можно использовать компактную запись, похожую на ту запись, что
была использована при решении обычных систем линейных уравнений:
.sp 0.5v
.EQ
left [
matrix {
ccol {{a sub 11} above {a sub 12} above {a sub 13}}
ccol {{a sub 21} above {a sub 22} above {a sub 23}}
ccol {{a sub 31} above {a sub 32} above {a sub 33}}
}
left |
matrix {
ccol {1 above 0 above 0}
ccol {0 above 1 above 0}
ccol {0 above 0 above 1}
}
right ""
right ]
~ .
.EN
.sp 0.5v
.PP
Далее, также как и при использовании обычного метода Гаусса\*-Жордана, левая
часть сводится к диагональной матрице, при этом все преобразования выполняются
и над правой частью. Сами неизвестные не пишутся, поэтому вместо них в левой
части в итоге должны быть единицы. Проще говоря, левая часть сводится к
единичной матрице:
.sp 0.5v
.EQ
left [
matrix {
ccol { {a sub 11} above {a sub 21} above {a sub 31} }
ccol { {a sub 12} above {a sub 22} above {a sub 32} }
ccol { {a sub 13} above {a sub 23} above {a sub 33} }
}
left |
matrix {
ccol { 1 above 0 above 0 }
ccol { 0 above 1 above 0 }
ccol { 0 above 0 above 1 }
}
right "" 
right ]
~~ -> ~~
pile {
left [
matrix {
ccol { {a sub 11}
above 0
above 0 }
ccol { {a sub 12}
above {{a dot} sub 22}
above {{a dot} sub 32} }
ccol { {a sub 13}
above {{a dot} sub 23}
above {{a dot} sub 33} }
}
left |
matrix {
ccol { 1 above {{b dot} sub 21} above {{b dot} sub 31} }
ccol { 0 above 1 above 0 }
ccol { 0 above 0 above 1 }
}
right "" 
right ]
~~ ,
above
lpile {
{a dot} sub 22 = a sub 22 - size -2 {a sub 21 over a sub 11} a sub 12
~ , ~~
{a dot} sub 23 = a sub 23 - size -2 {a sub 21 over a sub 11} a sub 13
~ , ~~
{b dot} sub 21 = - size -2 {a sub 21 over a sub 11}
~ ,
above
{a dot} sub 32 = a sub 32 - size -2 {a sub 31 over a sub 11} a sub 12
~ , ~~
{a dot} sub 33 = a sub 33 - size -2 {a sub 31 over a sub 11} a sub 13
~ , ~~
{b dot} sub 31 = - size -2 {a sub 31 over a sub 11}
~ .
}
}
~~ ->
.EN
.sp 0.5v
.EQ
-> ~~
pile {
left [
matrix {
ccol { {a sub 11}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22}
above 0 }
ccol { {{a dotdot} sub 13}
above {{a dot} sub 23}
above {{a dotdot} sub 33} }
}
left |
matrix {
ccol { {{b dotdot} sub 11} above {{b dot} sub 21} above {{b dotdot} sub 31} }
ccol { {{b dotdot} sub 12} above 1 above {{b dotdot} sub 32} }
ccol { 0 above 0 above 1 }
}
right "" 
right ]
~~ ,
above
lpile {
{a dotdot} sub 13 = a sub 13
- size -2 {a sub 12 over {a dot} sub 22} {a dot} sub 23
~ , ~~
{b dotdot} sub 11 = 1 - size -2 {a sub 12 over {a dot} sub 22} {b dot} sub 21
~ , ~~
{b dotdot} sub 12 = - size -2 {a sub 12 over {a dot} sub 22}
above
{a dotdot} sub 33 = {a dot} sub 33
- size -2 {{a dot} sub 32 over {a dot} sub 22} {a dot} sub 23
~ , ~~
{b dotdot} sub 31 = {b dot} sub 31
- size -2 {{a dot} sub 32 over {a dot} sub 22} {b dot} sub 21
~ , ~~
{b dotdot} sub 32 = - size -2 {{a dot} sub 32 over {a dot} sub 22}
}
}
~~ -> ~~
.EN
.sp 0.5v.
.EQ
~~ -> ~~
pile {
left [
matrix {
ccol { {a sub 11}
above 0
above 0 }
ccol { 0
above {{a dot} sub 22}
above 0 }
ccol {0 
above 0
above {{a dotdot} sub 33} }
}
left |
matrix {
ccol { {{b tilde} sub 11} above {{b tilde} sub 21} above {{b dotdot} sub 31} }
ccol { {{b tilde} sub 12} above {{b tilde} sub 22} above {{b dotdot} sub 32} }
ccol { {{b tilde} sub 13} above {{b tilde} sub 23} above 1 }
}
right "" 
right ]
~~ ,
above
lpile {
{b tilde} sub 11 = {b dotdot} sub 11
- size -2 {{a dotdot} sub 13 over {a dotdot} sub 33} {b dotdot} sub 31
~ , ~~
{b tilde} sub 11 = {b dotdot} sub 12
- size -2 {{a dotdot} sub 13 over {a dotdot} sub 33} {b dotdot} sub 32
~ , ~~
{b tilde} sub 13 = - size -2 {{a dotdot} sub 13 over {a dotdot} sub 33}
above
{b tilde} sub 21 = {b dot} sub 21
- size -2 {{a dot} sub 23 over {a dotdot} sub 33} {b dotdot} sub 31
~ , ~~
{b tilde} sub 22 = 1
- size -2 {{a dot} sub 23 over {a dotdot} sub 33} {b dotdot} sub 32
~ , ~~
{b tilde} sub 23 = - size -2 {{a dot} sub 23 over {a dotdot} sub 33}
}
}
~~ -> ~~
pile {
left [
matrix {
ccol { 1 above 0 above 0 }
ccol { 0 above 1 above 0 }
ccol { 0 above 0 above 1 }
}
left |
matrix {
ccol { {{b hat} sub 11} above {{b hat} sub 21} above {{b hat} sub 31} }
ccol { {{b hat} sub 12} above {{b hat} sub 22} above {{b hat} sub 32} }
ccol { {{b hat} sub 13} above {{b hat} sub 23} above {{b hat} sub 33} }
}
right "" 
right ]
~~ ,
above
lpile {
{b hat} sub 11 = size -2 {{{b tilde} sub 11} over {a sub 11}}
~ , ~~
{b hat} sub 12 = size -2 {{{b tilde} sub 12} over {a sub 11}}
~ , ~~
{b hat} sub 13 = size -2 {{{b tilde} sub 13} over {a sub 11}}
above
{b hat} sub 21 = size -2 {{{b tilde} sub 21} over {{a dot} sub 22}}
~ , ~~
{b hat} sub 22 = size -2 {{{b tilde} sub 22} over {{a dot} sub 22}}
~ , ~~
{b hat} sub 23 = size -2 {{{b tilde} sub 23} over {{a dot} sub 22}}
above
{b hat} sub 31 = size -2 {{{b dotdot} sub 31} over {{a dotdot} sub 33}}
~ , ~~
{b hat} sub 32 = size -2 {{{b dotdot} sub 32} over {{a dotdot} sub 33}}
~ , ~~
{b hat} sub 33 = size -2 {1 over {{a dotdot} sub 33}}
}
}
.EN
.sp 0.5v.
.PP
После этого, записав полученную матрицу в виде нескольких систем линейных
уравнений, можно получить значение каждой ячейки обратной матрицы:
.sp 0.5v.
.EQ
left {
lpile {
b sub 11 = {b hat} sub 11
above
b sub 21 = {b hat} sub 21
above
b sub 31 = {b hat} sub 31
}
right ""
~ , ~~
left {
lpile {
b sub 12 = {b hat} sub 12
above
b sub 22 = {b hat} sub 22
above
b sub 32 = {b hat} sub 32
}
right ""
~ , ~~
left {
lpile {
b sub 13 = {b hat} sub 13
above
b sub 23 = {b hat} sub 23
above
b sub 33 = {b hat} sub 33
}
right ""
.EN
.sp 0.5v.
Полностью алгоритм нахождения обратной матрицы можно записать так:
.sp 0.5v.
.RS
.PI
$a sub ij$ \*- элемент левой части, стоящий на $j$-й позиции в $i$-й строке.
.PI
$b sub ij$ \*- элемент правой части, стоящий на $j$-й позиции в $i$-й строке.
.RE
.sp 0.5v.
.RS
.PI 1.
Для каждого $i$ от $0$ до $n - 1$:
.RS
.PI
Для каждого $j$ от $0$ до $n - 1$:
.RS
.PI
Обнулить все элементы $i$-го столбца левой части, кроме того, что стоит на
главной диагонали:
.sp 0.5v
.EQ
a sub jk = a sub jk - size -2 {a sub ji over a sub ii} a sub ik
~ , ~~
b sub jk = b sub jk - size -2 {a sub ji over a sub ii} b sub ik
~ , ~~
k \(mo ^ [0 ; n - 1] ^ ;
.EN
.sp 0.5v
.RE
.RE
.PI 2.
Для каждого $i$ от $0$ до $n - 1$:
.RS
.PI
Для каждого $j$ от $0$ до $n - 1$:
.sp 0.5v
.EQ
a sub ij = size -2 {a sub ij over a sub ii}
~~ , ~
b sub ij = size -2 {b sub ij over a sub ii}
.EN
.sp 0.5v
.RE
.RE
.
.
.H1 "Работа с видеопотоком"
.PP
Видеопоток является цифровым представлением видео в форме непрерывно идущих
битов. Также как и аналоговое видео видеопоток содержит в себе отдельные
\*Iкадры\*P, которые должны идти с определенной частотой, например, 24 кадра в
секунду. Каждый кадр также представляет из себя набор битов. Если видеопоток не
закодирован, то он, по сути, является просто набором последовательно идущих
битовых представлений кадров.
.PP
Алгоритмы для поиска пластины с номером работают с отдельным изображением.
Чтобы сканировать с помощью них видеопоток, следует извлекать из этого
видеопотока кадры и уже работать с ними. Так как задача распознавания номеров
подразумевает использование видеопотока, поступающего в реальном времени,
возникает ряд проблем, которые необходимо решить.
.PP
Первая из них \*- это скорость работы алгоритмов, выполняющих поиск пластины с
номером. Так как одновременно можно работать только с одним кадром, то во время
его сканирования остальные кадры приходится пропускать. Понятно, что если между
обрабатываемым и пропущеными кадрами разница во времени небольшая, то
вероятность пропустить что-то важное тоже невелика. Однако, если сканирование
будет занимать слишком много времени, есть вероятность, что на пропущеных
кадрах может оказаться новая пластина с номером. 
.PP
Вторая проблема связана с первой. Как уже говорилось, кадры, приходящие во
время сканирования придется пропустить. А так как сканирование разных кадров
может занимать разное количество времени, необходимо определять, когда эти
кадры пропускать, а когда принимать. Данную проблему усугубляет тот факт, что в
случае закодированного видеопотока, о котором пойдет речь в следующем разделе,
каждый следующий кадр использует информацию из предыдущих. По этой причине,
приходится принимать кадры, даже если нет возможности их просканировать. 
.PP
Первая проблема была подробно рассмотрена во втором разделе. Именно для её
решения были выполнены все оптимизации, описанные в разделе, посвященном
каскадам Хаара. Вторая проблема решается с помощью выполнения сканирования и
декодирования кадров в разных процессах, используя средства межпроцессного
взаимодействия. Этому и посвящен данный раздел.
.
.H2 "Закодированный поток изображений"
.PP
Как уже говорилось, видеопоток в незакодированном виде является просто набором
последовательно идущих кадров. Однако, в таком виде для его передачи
потребуется канал с огромной пропускной способностью. К примеру, передача
видеопотока с разрешением $1280 times 720$, частотой $25$ кадров секунду и
глубиной цвета $10$ бит, где кадры представлены в цветовой схеме \*IY'CrCb\*P
с цветовой субдискретизацией $4:2:2$, потребует скорости как минимум $54,9$
мегабайт в секунду.
.PP
Однако, если использовать \*Iкодирование\*P, можно значительно снизить
требования к пропускной способности канала. Под кодированием видеопотока
обычно подразумевается его сжатие, т.е. изменение структуры данных в нем таким
образом, чтобы снизить количество передаваемой информации этом оставляя
неизменным или почти неизменным само видео, представляемое этим потоком.
.PP
Существует много разных способов кодирования видео (их иногда называют
\*Iкодеками\*P). Но, в основе большинства из них лежит одна и та же особенность
видео \*- многие пиксели в соседних кадрах имеют одинаковые или похожие
значения. Благодаря этому нет необходимости хранить значение каждого пикселя
каждого кадра.
.PP
К примеру, можно кодировать видео, запоминая значение каждого пикселя в
каком либо кадре, называемом ключевым кадром, и то, в скольки кадрах после
этого оно повторяется. Таким образом, для последующих кадров, не потребуется
передавать значение всех их пикселей. На практике используются более сложные
методы, однако, этот пример хорошо описывает принцип работы большинства из них.
.PP
Сторона, принимающая закодированный видеопоток, должна \*Iдекодировать\*P его,
чтобы извлекать из него кадры. И, как уже было написано выше, даже если нет
необходимости обрабатывать каждый кадр, при декодировании все-равно нужно
принимать весь видеопоток. Проблема, связанная с этим и её решение будут
описаны в разделе, посвященному сканированию непрерывного видеопотока. В данной
работе для приема видеопотока и его декодирования с последующим извлечением
кадров используется библиотека \*ILibAV\*P, которая подробно описана в
следующем разделе.
.
.H2 "LibAV"
LibAV \*- библиотека для работы с видеокодеками, которая предоставляет удобный
интерфейс на языке Си. В данном разделе описываются функции этой библиобтеки,
предназначенные для приема и декодирования видеопотока, а также основные
структуры используемые в LibAV.
.PP
В LibAV используется множетсво структур. Однако, для приема и декодирования
видеопотока достаточно только нескольких из них. Так как эти структуры имеют
очень много разных полей полного их описания приводиться не будет, а отдельные
поля будут описаны по необходимости.
.KS
.sp 0.5v
.nf
.in \n[PI]u
\*(CWstruct AVFormatContext\*P \*- содержит данные открытого видеопотока.
\*(CWstruct AVCodec\*P \*- содержит данные открытого видеокодека.
\*(CWstruct AVCodecContext\*P \*- контекст, позволяющий работать с открытым
кодеком.
.sp 0.5v
.KE
Открытие видеотока выполняется с помощью функции
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int avformat_open_input(AVFormatContext ** ps,
                        const char *       filename,
                        AVInputFormat *    fmt,
                        AVDictionary **    options
                       );
.KE
.sp 0.5v
, где \*(CWps\*P \*- структура, куда будут помещены данные открытого
видеопотока, \*(CWfilename\*P \*- имя открываемого видеопотока: может быть
как путём к файлу, так и URL, \*(CWfmt\*P \*- формат в котором следует
принимать видеопоток, если задан как \*(CWNULL\*P, то формат выбирается
автоматически, а \*(CWoptions\*P \*- дополнительные опции, может передаваться
как \*(CWNULL\*P.
.PP
Видеопоток может также содержать аудиопоток, идущий одновременно с ним. Поэтому
необходимо найти в нем поток содержащий именно видеоинформацию. Для это этого
сначала необхомо вызвать функцию
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int avformat_find_stream_info(AVFormatContext * ic,
                              AVDictionary **   options
                             );
.KE
.sp 0.5v
, где \*(CWic\*P \*- открытый видеопоток, а \*(CWoptions\*P \*- дополнительные
опции, может передаваться как \*(CWNULL\*P.
.PP
Эта функция позволяет получить данные о характеристиках открытого видеопотока,
считав из него несколько кадров. Полученные данные записываются в
соответствующие поля первого аргумента.
.PP
После этого можно найти необходимый поток, проверяя поле \*(CWcodec\*P в каждом
из потоков в структуре \*(CWAVFormatContext\*P.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
for (sn = 0; sn < s-> nb_streams; ++sn)
	if (s->streams[sn]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
		vstreamid = sn;
.KE
.sp 0.5v.
.PP
Поле \*(CWstreams\*P является массивом структур \*(CWAVStream\*P, в котором
каждый элемент соответствует одному потоку. Полу \*(CWcodec\*P является
указателем на контекст кодека, связанного с этим потоком, а поле
\*(CWcodec_type\*P структуры \*(CWAVCodecContext\*P является элементом
перечисления \*(CWAVMediaType\*P, показывающим тип информации, с которой
работает этот кодек.
.PP
После того как открыт сам видеопоток, необходимо открыть соответствующий
видеокодек. Для этого кодек сначала ищется в системе функцией
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
AVCodec * avcodec_find_decoder(enum AVCodecID id);
.KE
.sp 0.5v
, где \*(CWid\*P \*- идентификатор искомого кодека, содержащийся в структуре
\*(CWAVStream\*P открытого видеопотока. После этого из открытого видеопотока
копируется контекст. Чтобы это сделать надо выделить для него память функцией
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
AVCodecContext * avcodec_alloc_context3(const AVCodec *codec);
.KE
.sp 0.5v
, где \*(CWcodec\*P \*- это кодек, для которого создается контекст. А затем
копировать значения полей из контекста в открытом видеопотоке функцией
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int avcodec_copy_context(AVCodecContext *       dest,
                         const AVCodecContext * src
                        );
.KE
.sp 0.5v
, где \*(CWdest\*P \*- структура, куда выполняется копирование, а \*(CWsrc\*P
\*- структура, из которой выполняется копирование. Некоторые форматы устроены
так, что в присылаемом пакете может быть неполный кадр. Необходимо проверить,
может ли выбранный кодек работать в таком режиме, и, если может, установить
соответствующий флаг в его контексте:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
if (vcodec->capabilities & CODEC_CAP_TRUNCATED)
	vcodecc->flags |= CODEC_FLAG_TRUNCATED;
.KE
.sp 0.5v
, где \*(CWvcodec\*P \*- кодек, а vcodecc \*- связаный с ним контекст. Далее
кодек открывается с помощью фукнции
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
avcodec_open2(AVCodecContext * avctx,
              const AVCodec *  codec,
              AVDictionary **  options
             );
.KE
.sp 0.5v
, где \*(CWavctx\*P \*- контекст, связанный с открываемым кодеком,
\*(CWcodec\*P \*- открываемый кодек, а \*(CWoptions\*P \*- дополнительные
опции, может передаваться как \*(CWNULL\*P. После этого контекст можно
использовать для декодирования принимаемого видеопотока.
.PP
После того, как были открыт видеопоток и кодек, связаный с ним, можно принимать
и декодировать кадры. Для это используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int av_read_frame(AVFormatContext * s,
                  AVPacket *        pkt
                 );
.KE
.sp 0.5v
, где первый аргумент \*- открытый видеопоток, а второй агрумент \*- структура
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
struct AVPacket;
.KE
.sp 0.5v
в которой, в незакодированном виде сохраняются принятые данные. Если элемент
\*(CWbuf\*P этой структуры в данном аргументе имеет значение \*(CWNULL\*P, то
функция \*(CWav_read_frame\*P сохранит данные во внутреннем буффере LibAV.
.PP
Далее выполняется попытка декодировать полученные данные с помощью функции
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int avcodec_decode_video2(AVCodecContext * avctx,
                          AVFrame *        picture,
                          int *            got_picture_ptr,
                          const AVPacket * avpkt
                         );
.KE
.sp 0.5v
, где \*(CWavctx\*P \*- контекст кодека, которым будут декодироваться данные,
\*(CWpicture\*P \*P- структура
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
struct AVFrame;
.KE
.sp 0.5v
в которую записывается декодированный кадр, \*(CWgot_picture_ptr\*P \*- адрес
объявленного пользователем целого числа, куда будет записан $0$, если этих
данных недостаточно для декодирования полноценного кадра, или $1$, если кадр
был успешно декодирован, а \*(CWavpkt\*P \*- декодируемые данные.
.PP
Аргумент \*(CWgot_picture_ptr\*P используется именно по той причине, что
принятые данные не обязательно будут содержать полный кадр. Поэтому в случае,
когда по адресу, указанному в этом аргументе оказывается $0$, LibAV, запомнив
переданные в аргументе $avpkt$ данные, ожидает повторного вызова функции
\*(CWavcodec_decode_video2\*P и не возвращает ошибки.
.PP
Для инициализации структуры \*(CWAVFrame\*P используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
AVFrame* av_frame_alloc(void);
.KE
.sp 0.5v
возвращающая указатель на эту структуру для которой уже выделена память и
установлены значения полей по умолчанию. Если эта структура больше не
требуется, то вызывается функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
void av_frame_free(AVFrame ** frame);
.KE
.sp 0.5v
освобождающая выделенную для нее память.
.PP
Также необходимо учесть, что полученнные данные не обязательно являются
видеоданными. Они могут, например, являться данными параллельно идущего с видео
аудиопотока. Для того, чтобы узнать к какому потоку относятся данные можно
проверить значение поля \*(CWstream_index\*P структуры \*(CWAVPacket\*P сравнив
его с найденным при открытии видеопотока номера потока содержащего видео.
.PP
После того, как была выполнена попытка декодировать кадр, независмо от успеха,
из структуры \*(CWAVPacket\*P удаляется ссылка на буффер, в котором были
сохранены данные. Делается это с помощью функции
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
void av_packet_unref(AVPacket * pkt);
.KE
.sp 0.5v
, \*(CWpkt\*P \*- структура, содержащая принятые данные.
.PP
Для удобства в данной работе написана функция \*(CWreadframe\*P, вызывающая
внутри себя функции \*(CWav_read_frame\*P и \*(CWav_codec_decode_video2\*P:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int readframe(AVFormatContext *s, AVCodecContext *vcodecc,
	int vstreamid, AVFrame *frame, int *isdecoded)
{
	AVPacket pack;
	int ret;
	
	memset(&pack, 0, sizeof(AVPacket));
	pack.data = NULL;
	pack.buf = NULL;
	pack.size = 0;

	if ((ret = av_read_frame(s, &pack)) < 0) {
		if (ret != AVERROR_EOF) {
			char buf[255];
			
			av_strerror(ret, buf, 255);
			fprintf(stderr, "%s\n", buf);

			return (-1);
		}

		return 1;
	}
	
	if (pack.stream_index == vstreamid) {
		int cret;

		if ((cret = avcodec_decode_video2(vcodecc, frame,
			isdecoded, &pack)) < 0) {
			char buf[255];
			
			av_strerror(cret, buf, 255);
			fprintf(stderr, "%s\n", buf);

			return (-1);
		}
	}

	av_packet_unref(&pack);

	return 0;
}
.KE
.sp 0.5v
.PP
Аргумент \*(CWs\*P \*- открытый видеопоток, \*(CWvodecc\*P \*- кодек,
предназначеный для декодирования этого видеопотока, \*(CWvstreamid\*P \*-
номер потока с видео, \*(CWframe\*P \*- структура, куда будет сохранён
полученный кадр, должна быть инициализирована пользователем, а
\*(CWisdecoded\*P \*- аналогична аргументу \*(CWgot_picture_ptr\*P функции
\*(CWav_codec_decode_video2\*P.
.H2 "Сканирование непрерывного видеопотока"
.PP
При работе с непрерывным видеопотоком сканирование и декодирование выполняется
в разных процессах. Так как большинство современных компьютеров способны
одновременно выполнять несколько процессов, это решает проблему связанную с 
необходимостью непрерывно принимать кадры: пока один процесс сканирует с
доступной ему скоростью, другой процесс продолжает приём и декодирование.
.PP
Однако, возникает другая проблема \*- декодирующий процесс должен каким-то
образом передавать сканирующему новые кадры. В данной работе для этого
используются способы межпроцессного взаимодействия систем семейства Unix.
Для передачи декодирующим процессом готовых кадров используется разделяемый
сегмент памяти, к которому имеют доступ оба процесса. А для управления порядком
доступа к этому сегменту используется неименованный канал.
.PP
Для порождения новых процессов используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
pid_t fork(void);
.KE
.sp 0.5v
, создающая точную копию вызывающего процесса. Причем, в родительском процессе
она возвращает \*Ipid\*P (идентификатор процесса в системе) дочернего процесса,
а в дочернем возвращает $0$. Благодаря этому решаются сразу две проблемы.
Во-первых, проверяя возвращаемое значение, можно разделить код на тот, что
выполняется в дочернем процессе, тот что выполняется в родительском. Во-вторых,
идентификаторы \*- это способ для родительского процесса различать дочерние.
.PP
Чтобы создать разделяемую область памяти, используется функция, изначально
предназначенная для отображения файлов и устройств в память:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
void *mmap(void *addr, size_t length, int prot,
           int flags, int fd, off_t offset);
.KE
.sp 0.5v
, где \*(CWaddr\*P \*- адрес, в который требуется выполнить отображение, если
он передаётся как \*(CWNULL\*P, то ядро системы само выбирает адрес,
\*(CWlength\*P \*- длина отображения в байтах, \*(CWprot\*P \*- разрешенные
способы доступа, \*(CWflags\*P \*- определяет, доступно ли данное отображение
другим процессам, а также позволяет управлять радом других возможностей,
\*(CWfd\*P \*- дескриптор файла или устройства, которое требуется отобразить,
а \*(CWoffset\*P \*- смещение в отображаемом файле или устройстве. Возвращаемое
значение \*- указатель на область памяти, в которую было выполнено отображение.
.PP
Данная функция позволяет создавать анонимные отображения, не требующие привязки
к какому-либо файлу или устройству. Если сделать такое отображение доступным
другим процессам, то после вызова \*(CWfork\*P к этой области памяти смогут
обращаться и родительский, и дочерний процесс. Разделяемое аноминое отображение
создаётся путем передачи в аргумент \*(CWflags\*P скомбинированных с помощью
побитового \*Qили\*U значений \*(CWMAP_ANON\*P и \*(CWMAP_SHARED\*P.
.PP
Для того, чтобы удалить созданное отображение, используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int munmap(void *addr, size_t length);
.KE
.sp 0.5v
, где \*(CWaddr\*P \*- адрес, в который было выполнено отображение, а
\*(CWlength\*P \*- длина этого отображения.
.PP
Неименованный канал позволяет передавать данные между родственными процессами
и представляет из себя связку из двух дескрипторов: дескриптор для записи и
дескриптор для чтения. Все данные, записанные в первый дескриптор, можно
считать через второй. А так как при вызове функции \*(CWfork\*P открытые
дескрипторы родительского процесса копируются, то если один из родственных
процессов будет записывать данные в дескриптор для записи, другой сможет их
прочитать из дескриптора для чтения. Из-за принципа их работы, неименованные
каналы называют трубами (\*(CWpipes\*P).
.PP
Для создания неименованных каналов используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int pipe(int pipefd[2]);
.KE
.sp 0.5v
, где \*(CWpipefd\*P \*- массив из двух целых: после вызова функции его первый
элемент будет дескриптором для чтения, а второй \*- дескриптором для записи.
Данная функция возвращает $0$, если выполнена успешно и $-1$ в случае ошибки.
Если один созданных дескприпторов больше не нужен, его, как и любой другой
дескриптор, следует закрыть функцией
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int close(int fd);
.KE
.sp 0.5v
, где \*(CWfd\*P \*- закрываемый дескриптор.
.PP
Для записи в неименованный канал используется функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
ssize_t write(int fd, void *buf, size_t count);
.KE
.sp 0.5v
, где \*(CWfd\*P \*- дескриптор, в который выполняется запись, \*(CWbuf\*P \*-
буффер, содержимое которого требуется записать в дексриптор, а \*(CWcount\*P
\*- количество байт из \*(CWbuf\*P, которое необходимо записать.
.PP
Для чтения из неименованного канала используется функция:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
ssize_t write(int fd, void *buf, size_t count);
.KE
.sp 0.5v
, где \*(CWfd\*P \*- дескриптор, из которого выполняется чтение, \*(CWbuf\*P
\*- буффер, в который будет записаны прочитанные данные, а \*(CWcount\*P \*-
количество байт , которое требуется прочитать из дескриптора.
.PP
Для того чтобы узнать можно ли считать данные с дескритора, используется
функция
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int select(int nfds, fd_set *readfds, fd_set *writefds,
	fd_set *exeptfds, struct timeval *timeout);
.KE
.sp 0.5v
, где \*(CWnfds\*P самый большой номер среди номеров всех дескрипторов из
наборов, передаваемых тремя следующими аргументами, увеличенный на $1$,
\*(CWreadfds\*P \*- набор дескрипторов, на которых ожидается операция чтения,
\*(CWwritefds\*P \*- набор дескрипторов, на которых ожидается операция записи,
\*(CWexceptfds\*P \*- набор дескрипторов, на которых ожидаются исключения,
а \*(CWtimeout\*P \*- структура, задающая время ожидания.
.PP
Набор дескрипторов является последовательностью байтов, где каждый $i$-й байт
соответствует дескриптору с номером $i$. Если какой-либо бит в наборе
установлен, то при передаче этого набора функции \*(CWselect\*P, будет
ожидаться событие (чтение, запись, исключение) на соответствующем этому биту
дескрипторе. Обнуление набора дескрипторов выполняется макросом
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
void FD_ZERO(fd_set *set);
.KE
.sp 0.5v
, где \*(CWset\*P \*- обнуляемый набор. Установка бита соответствующего нужному
дескриптору выполняется макросом
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
void FD_SET(int fd, fd_set *set);
.KE
.sp 0.5v
, где \*(CWfd\*P \*- дескриптор, соответствующий которому бит нужно установить,
а \*(CWset\*P \*- набор, в котором этот бит устанавливается.
.PP
Функция \*(CWselect\*P имеет широкое применение, однако в данной работе она
применяется только для проверки того, можно ли считать байт из дескриптора для
чтения неименованного канала.
.
.
.H2 "Синхронизация процессов" "с помощью неименованных каналов"
.PP
Для передачи кадров используется разделяемая память. Если декодирующему
процессу требуется передать кадр, он копирует его в заранее созданый участок
разделяемой памяти. Если сканирующему процессу требуется получить новый кадр,
он читает его из этого же участка разделяемой памяти.
.PP
Возникает проблема: сканирующий процесс может начать читать кадр, в то время
как декодирующий процесс записывает новый. Решить эту проблему можно добавив
механизм, позволяющий процессу узнать, можно ли в данный момент обращаться к
данному участку разделяемой памяти. Иначе говоря, требуется реализовать
механизм синхронизации процессов.
.PP
Реализованный в данной работе представляет интерфейс из нескольких функций:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psinitprefork();
.KE
.sp 0.5v
вызывается перед вызовом функции \*(CWfork\*P. Инициализирует механизм
синхронизации. Возвращает $0$ в случае успешно выполнения и $-1$ в случае
ошибки.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psinitpostfork(int pn);
.KE
.sp 0.5v
, где \*(CWpn\*P \*- номер процесса, из которого выполняется вызов: $0$ \*-
декодирующий, а $1$ \*- сканирующий. Вызывается после вызова функции
\*(CWfork\*P в обоих процессах. Завершает инициализацию для каждого процесса
отдельно.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_pslock(int pn);
.KE
.sp 0.5v
, где \*(CWpn\*P \*- номер процесса, из которого выполняется вызов. Вызывается
перед работой с разделяемым участком памяти. Блокирует выполнение программы,
пока другой процесс не сообщит о том, что он завершил работу с требуемым
участком памяти. Возвращает $0$ в случае успешно выполнения и $-1$ в случае
ошибки.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psunlock(int pn);
.KE
.sp 0.5v
, где \*(CWpn\*P \*- номер процесса, из которого выполняется вызов. Вызывается
после завершения работы с разделяемым участком памяти. Сообщает другому
процессу, о том, что работа с данным участком завершена. Возвращает $0$ в
случае успешно выполнения и $-1$ в случае ошибки.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_pstrylock(int pn);
.KE
.sp 0.5v
, где \*(CWpn\*P \*- номер процесса, из которого выполняется вызов. Как и
\*(CWnd_pslock\*P, вызывается перед работой с разделяемым участком памяти, но
в отличие от него не блокирует выполнение программы. Возвращает $0$, требуемый
участок памяти занят, $1$, если свободен и $-1$ в случае ошибки.
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psunlock(int pn);
.KE
.sp 0.5v
, где \*(CWpn\*P \*- номер процесса, из которого выполняется вызов. Вызывается
перед завершением работы процесса. Завершает работу механизма синхронизации.
.PP
Данные функции реализованы с помощью двух неименованных каналов. Если процессу
нужно получить доступ к учаску разделяемой памяти, он пытается считать из
одного канала байт, а если он завершил работу с этим участком он записывает
байт в другой канал. Первый процесс читает из первого канала и записывает во
второй, а другой процесс наоборот, записывает в первый канал и читает из
второго.
.PP
Дескрипторы для чтения и записи обоих каналов объявлены как
статические переменные в том же файле исходного кода, что и остальные функции
механизма синхронизации:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
static int pfdc[2];
static int pfdp[2];
.KE
.sp 0.5v
.PP
Функция \*(CWnd_psinitprefork\*P создает оба неименованных канала, а также
вызавает функцию \*(CWnd_psunlock\*P, чтобы разблокировать участок разделяемой
памяти для декодирующего процесса:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psinitprefork()
{	
	if (pipe(pfdc) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}

	if (pipe(pfdp) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}
	
	if (nd_psunlock(1) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}

	return 0;
}
.KE
.sp 0.5v
.PP
Функция \*(CWnd_initpostfork\*P закрывает те дескрипторы, среди открытых
функцией \*(CWnd_psinitprefork\*P, которые не будут использоваться в конкретном
процессе:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psinitpostfork(int pn)
{
	assert(pn <= 1 && pn >= 0);

	if (pn == 0) {
		if (close(pfdc[0]) < 0 || close(pfdp[1]) < 0) {
			nd_seterrormessage("pipe error", __func__);
			return (-1);
		}
	}
	else {
		if (close(pfdc[1]) < 0 || close(pfdp[0]) < 0) {
			nd_seterrormessage("pipe error", __func__);
			return (-1);
		}
	}

	return 0;
}
.KE
.sp 0.5v
.PP
Функция \*(CWnd_pslock\*P блокирует процесс, пока не будет считан байт с
соответстующего неименованного канала:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_pslock(int pn)
{
	int c;
	char buf[1024];
	int fd;

	assert(pn <= 1 && pn >= 0);

	fd = (pn == 0) ? pfdp[0] : pfdc[0];

	if ((c = read(fd, buf, 1024)) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}

	return 0;
}

.KE
.sp 0.5v
.PP
Функция \*(CWnd_psunlock\*P отправляет байт в соответствующий неименованный
канал:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_psunlock(int pn)
{
	int c;
	int fd;

	assert(pn <= 1 && pn >= 0);

	fd = (pn == 0) ? pfdc[1] : pfdp[1];
	
	if ((c = write(fd, "u", 1)) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}

	return 0;
}
.KE
.sp 0.5v
.PP
Функция \*(CWnd_pstrylock\*P проверяет с помощью функция \*(CWselect\*P, можно
ли считать байт из соответствующего неименнованого канала, и, если это
возможно, считывает, иначе, возвращает $0$:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int nd_pstrylock(int pn)
{
	fd_set readfs;
	struct timeval tv;
	int retval;
	int fd;

	assert(pn <= 1 && pn >= 0);
.KE
.KS
.nf
.in \n[PI]u
.CW

	fd = (pn == 0) ? pfdp[0] : pfdc[0];

	FD_ZERO(&readfs);
	FD_SET(fd, &readfs);

	tv.tv_sec = 0;
	tv.tv_usec = 0;

	if ((retval = select(fd + 1, &readfs, NULL, NULL, &tv)) < 0) {
		nd_seterrormessage("pipe error", __func__);
		return (-1);
	}

	if (retval > 0) {
		if (nd_pslock(pn) < 0)
			return (-1);

		return 1;
	}
	
	return retval;
}
.KE
.sp 0.5v
.PP
Функция \*(CWnd_psclose\*P закрывает все дескрипторы, используемые для
синхронизации:
.KS
.nf
.in \n[PI]u
.CW
int nd_psclose(int pn)
{
	assert(pn <= 1 && pn >= 0);
	
	if (pn == 0) {
		if (close(pfdp[0]) < 0 || close(pfdc[1]) < 0) {
			nd_seterrormessage("pipe error", __func__);
			return (-1);
		}
	}
	else {
		if (close(pfdp[1]) < 0 || close(pfdc[0]) < 0) {
			nd_seterrormessage("pipe error", __func__);
			return (-1);
		}
	}

	return 0;
}
.KE
.sp 0.5v
.
.
.H2 "Декодирующий процесс"
.PP
Декодирующий процесс читает кадры в бесконечном цикле. На каждой итерации,
сначала с помощью функции \*(CWreadframe\*P из видеопотока считываются данные,
пока не будет декодирован один кадр. После этого считаный кадр переводится в
цветовую схему RGB, а также создаётся его уменшенная копия, которая будет
использоваться при сканировании.
.PP
Далее процесс пытается получить доступ к разделяемой памяти. Если она занята,
то полученный кадр и его уменьшенная удаляются и процесс переходит к следующей
итерации. Если процесс получает доступ к разделяемой памяти, он копирует в нее
кадр и его уменьшенную копию и сообщает о завершении работы с разделяемой
памятью.
.PP
В качестве первого аргумента функция основного цикла декодирующего процесса
принимает структуру
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
struct avdata {
	AVFormatContext *s;
	AVCodecContext *vcodecc;
	AVFrame *frame;
	int vstreamid;
};

.KE
.sp 0.5v
, в которой содержатся все необходимые для работы с видеопотоком структуры.
Предполагается, что они инициализированы перед началом основного цикла.
.PP
В качестве второго и третьего аргумента принимаются структуры предназначенные
для представления изображения в удобной для распознавания форме:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
struct nd_image {
	int w;
	int h;
	enum ND_PIXELFORMAT format;
	double *data;
};
.KE
.sp 0.5v
, где \*(CWw\*P и \*(CWh\*P \*- ширина и высота изображения соответственно,
\*(CWformat\*P \*- формат пикселей (ARGB, RGB, Grayscale), а \*(CWdata\*P \*-
данные изображения. Данные обоих изображений, передаваемых в функцию основного
цикла декодирующего процесса разположены в разделяемом участке памяти и
используются для передачи кадров сканирующему процессу.
.PP
Ниже приведен исходный код функции основного цикла декодирующего процесса:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int decodeloop(struct avdata *av, struct nd_image *img,
	struct nd_image *imgorig)
{
	struct playbackstate pbs;
	AVRational tmpr;

	tmpr = av->s->streams[av->vstreamid]->avg_frame_rate;
	if (pbstateinit(&pbs, (double) tmpr.num / tmpr.den) < 0)
		return 1;

	while (1) {
		int isdecoded;
		uint8_t *rgbdata;
		uint8_t *rgbdataorig;
		int rgblinesize;
		int rgblinesizeorig;
		int retval;

		isdecoded = 0;
.KE
.KS
.nf
.in \n[PI]u
.CW

		do {
			if ((retval = readframe(av->s, av->vcodecc,
				av->vstreamid, av->frame, &(isdecoded))) < 0)
				return (-1);

			if (retval > 0)
				return 0;
		} while (!isdecoded);

		if (frametorgb(av->frame, img->w, img->h,
			&rgbdata, &rgblinesize) < 0)
			return (-1);

		if (frametorgb(av->frame, imgorig->w, imgorig->h,
			&rgbdataorig, &rgblinesizeorig) < 0)
			return (-1);

		if (nd_pstrylock(0)) {
			rgbdatatoimg(rgbdata, rgblinesize, img);
			rgbdatatoimg(rgbdataorig, rgblinesizeorig, imgorig);
			
			if (nd_psunlock(0) < 0) {
				fprintf(stderr, nd_geterrormessage());
				return (-1);
			}
		}

		free(rgbdata);
		free(rgbdataorig);
	}

	fprintf(stderr, "Unexpexted loop quit\n");
	return (-1);
}
.KE
.sp 0.5v
.
.H2 "Сканирующий процесс"
.PP
Сканирующий процесс загружает из памяти данные заранее обученного каскада
Хаара, а затем устанавливает для него стандартную конфигурацию. После этого
запускается бесконечный цикл, в котором на каждой итерации процесс ждет пока
не освободится участок разделяемой памяти, и как только она освобождается,
выполняет необходимые для распознавания действия. Когда сканирование кадра
завершено, процесс сообщает о завершении работы с разделяемой памятью.
.PP
Основная функция сканирующего процесса принимает первыми двумя аргументами
изображения, представленные структурой \*(CWstruct nd_image\*P. Как в случае
с декодирующем процессом, данные этих изображений расположены в разделяемой
памяти и через них сканирующий процесс принимает кадры. Третьим аргументом
данная функция принимает путь к данным заранее обученного каскада Хаара. А
Четвертый аргумент \*- это путь к директории куда следует сохранять изображения
обнаруженный номеров.
.PP
Ниже приведен исходный код основной функции сканирующего процесса:
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW
int scanloop(struct nd_image *img, struct nd_image *imgorig,
	const char *hcpath, const char *outputdir)
{
	struct hcdata hcd;

	if (hc_hcascaderead(&(hcd.hc), hcpath) < 0) {
		fprintf(stderr, nd_geterrormessage());
		return (-1);
	}

	hc_confbuild(&(hcd.scanconf),
		hcd.hc.ww, hcd.hc.wh, img->w, img->h,
		0.9, 1, 1, threadcount);

	while (1) {
		struct nd_matrix3 perspmat;
		struct hc_rect *r;
		int rc;

		if (nd_pslock(1) < 0) {
			fprintf(stderr, nd_geterrormessage());
			return (-1);
		}

		if (img->data == NULL)
			return 0;
		
		if (getperspmat(img->w, img->h, &perspmat) < 0)
			return (-1);
	
		if (nd_imgapplytransform(img, &perspmat) < 0) {
			fprintf(stderr, nd_geterrormessage());
			return (-1);
		}

		if (hc_imgpyramidscan(&(hcd.hc), img, &r, &rc,
			&(hcd.scanconf)) < 0) {
			fprintf(stderr, nd_geterrormessage());
			return (-1);
		}
	
		if (rc) {
			printf("Detected.\n");
			detectedtofile(img, imgorig, &perspmat,
				r, rc, outputdir);
			free(r);
		}
.KE
.sp 0.5v
.KS
.nf
.in \n[PI]u
.CW

		if (nd_psunlock(1) < 0) {
			fprintf(stderr, nd_geterrormessage());
			return (-1);
		}
	}

	fprintf(stderr, "Unexpexted loop quit\n");
	return (-1);
}
.KE
.sp 0.5v

.
.
.H1 "Заключение"
.PP
В результате проделанной работы был написан набор утилит для Unix-подобных
систем, предназначенных для распознавания номеров. Их список включает в себя:
утилиту для поиска слабых классификаторов каскада Хаара, утилиту для построения
каскада Хаара из найденных примитивов, утилиту для поиска объектов на
изображении с помощью обученного каскада Хаара (имеется уже обученный под поиск
пластины с номером каскад), а также утилиту для исправления перспективных
искажений в найденном изображении с пластиной.
.PP
Структура каскадов Хаара и алгоритм обучения были реализованы на основе
оригинальной статьи. Также была предпринята попытка объяснить их суть
доступным языком. Был добавлен ряд оптимизаций, не описаных в оригинальной
статье, значительно увеличивающих скорость обучения.
.PP
Алгоритмы и фильтры, используемые при исправлении искажений перспективы
(оператор Собеля, метод Оцу, детектор границ Канни, преобразование Хафа)
были реализованы на основе их описаний в книге "Цифровая обработка изображений"
Рафаеля Гонзалеза и Ричарда Вудса. При изучении особенностей фотографий с
изображением автомобильных номеров был определен способ совмещения этих
алгоритмов и фильтров, дающий описаные ниже результаты, а также были добавлены
дополнительные алгоритмы для улучшения качества обнаружения границ.
.PP
Данная работа имеет ряд недостатков. Каскад Хаара не может обнаружать
объекты, сильно наклоненные относительно того объекта, под который он обучался.
Поэтому, автомобильные номера, сфотографированные под нестандартными углами,
обычно не обнаружаются. Это не является серьезным недостатком, так как
написанные утилиты в основном предназначены для специальных камер, снимающих
машины под требуемым углом. Также, эту проблему можно решить, проверяя
помимо исходного изображения его копии, повернутые на фиксированный угол. 
.PP
Детектор границ Канни периодически может давать сбой. Это обычно связано с
плохим освешением, грязными номерами, большим уровнем шума, яркими границами у
пластины с номером или её физизескими искажениями (например, если пластина с
номером загнута). В итоге, для дальнейшего распознавания пригодно только около
$80%$ обнаруженных номеров.
.PP
Дальнешую работу планируется направить на исправление описанных выше
недостатков. После этого планируется искать способы распознавания отдельных
символов на изображении, полученном после исправления перспективных искажений.
.
.
.H1 "Список литературы"
.RS
.PI 1.
\*IAn Introduction to Practical Neural Networks and Genetic Algorithms For
Engineers and Scientists. Christopher MacLeod.\*P \*- небольшая книга,
посвященная нейронным сетям и генетическим алгоритмам. Также, в ней описаны
разные методы, применяемые при машинном обучении.
.PI 2.
\*IRapid Object Detection using a Boosted Cascade of Simple Features.
Paul Viola, Michael Jones.\*P \*- оригинальная статья, в которой были
представлены каскады Хаара, содержит часть информации, необходимой для их
реализации.
.PI 3.
\*IDigital Image Processing. Rafael C. Gonzalez, Richard E. Woods.\*P \*-
книга, посвященная цифровой обработке изображений. В ней описывается большая
часть методов, применяемых в этой работе при исправлении искажений перспективы.
.PI 4.
\*IБез паники! Цифровая обработка сигналов. Юкио Сато.\*P \*- введение в
цифровую обработку сигналов.
.PI 5.
\*IThe Scientist and Engineer's Guide to Digital Signal Processing.
Steven W. Smith.\*P \*- книга, посвященная цифровой обработке сигналов. В ней
описано множетсво методов, применяемых улучшении сигналов и их анализе.
.RE
